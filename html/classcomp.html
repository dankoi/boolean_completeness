<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>classcomp</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library classcomp</h1>

<div class="code">
</div>

<div class="doc">
   Krivine's constructive proof of completeness for classical
   first-order logic, following the paper of Berardi and Valentini.

<br/> <br/>
   Uses Russell O'Connor's implementation of the Cantor Pairing
   function in Coq.

<br/> <br/>
   A part involving list sorting is not fully formalised.

<br/> <br/>
   Danko Ilik, October 2008

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#"><span class="id" type="library">List</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Setoids.Setoid.html#"><span class="id" type="library">Setoid</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Bool.Bool.html#"><span class="id" type="library">Bool</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Arith.EqNat.html#"><span class="id" type="library">EqNat</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Arith.Peano_dec.html#"><span class="id" type="library">Peano_dec</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Arith.Compare_dec.html#"><span class="id" type="library">Compare_dec</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Arith.Max.html#"><span class="id" type="library">Max</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Arith.Le.html#"><span class="id" type="library">Le</span></a>.<br/>

<br/>
</div>

<div class="doc">
This imports the proof of the constructive Ultra-filter Theorem 
</div>
<div class="code">
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="filters.html#"><span class="id" type="library">filters</span></a>.<br/>
</div>

<div class="doc">
This imports the unfinished list-sorting library
</div>
<div class="code">
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="lists.html#"><span class="id" type="library">lists</span></a>.<br/>

<br/>

<br/>

<br/>
</div>

<div class="doc">
To build the syntax of formulas, we start with decidable countable sets of constant, function, and predicate symbols. 
</div>
<div class="code">
<span class="id" type="keyword">Module</span> <span class="id" type="keyword">Type</span> <a name="classical_completeness_signature"><span class="id" type="module">classical_completeness_signature</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span><span class="id" type="var">s</span> <a name="classical_completeness_signature.function"><span class="id" type="axiom">function</span></a> <a name="classical_completeness_signature.predicate"><span class="id" type="axiom">predicate</span></a> <a name="classical_completeness_signature.constant0"><span class="id" type="axiom">constant0</span></a> : <span class="id" type="keyword">Set</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <a name="classical_completeness_signature.function_dec"><span class="id" type="axiom">function_dec</span></a> : ∀ <span class="id" type="var">f1</span> <span class="id" type="var">f2</span>:function, {<span class="id" type="var">f1</span> = <span class="id" type="var">f2</span>} + {<span class="id" type="var">f1</span> ≠ <span class="id" type="var">f2</span>}.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <a name="classical_completeness_signature.predicate_dec"><span class="id" type="axiom">predicate_dec</span></a> : ∀ <span class="id" type="var">f1</span> <span class="id" type="var">f2</span>:predicate, {<span class="id" type="var">f1</span> = <span class="id" type="var">f2</span>} + {<span class="id" type="var">f1</span> ≠ <span class="id" type="var">f2</span>}.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <a name="classical_completeness_signature.constant0_dec"><span class="id" type="axiom">constant0_dec</span></a> : ∀ <span class="id" type="var">f1</span> <span class="id" type="var">f2</span>:constant0, {<span class="id" type="var">f1</span> = <span class="id" type="var">f2</span>} + {<span class="id" type="var">f1</span> ≠ <span class="id" type="var">f2</span>}.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <a name="classical_completeness_signature.enum_function"><span class="id" type="axiom">enum_function</span></a> : <a class="idref" href="classcomp.html#classical_completeness_signature.function"><span class="id" type="axiom">function</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <a name="classical_completeness_signature.enum_predicate"><span class="id" type="axiom">enum_predicate</span></a> : <a class="idref" href="classcomp.html#classical_completeness_signature.predicate"><span class="id" type="axiom">predicate</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <a name="classical_completeness_signature.enum_constant0"><span class="id" type="axiom">enum_constant0</span></a> : <a class="idref" href="classcomp.html#classical_completeness_signature.constant0"><span class="id" type="axiom">constant0</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <a name="classical_completeness_signature.enum_function_inj"><span class="id" type="axiom">enum_function_inj</span></a> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∀ <span class="id" type="var">p</span> <span class="id" type="var">q</span>, <a class="idref" href="classcomp.html#classical_completeness_signature.enum_function"><span class="id" type="axiom">enum_function</span></a> <span class="id" type="var">p</span> = <a class="idref" href="classcomp.html#classical_completeness_signature.enum_function"><span class="id" type="axiom">enum_function</span></a> <span class="id" type="var">q</span> → <span class="id" type="var">p</span> = <span class="id" type="var">q</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <a name="classical_completeness_signature.enum_predicate_inj"><span class="id" type="axiom">enum_predicate_inj</span></a> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∀ <span class="id" type="var">p</span> <span class="id" type="var">q</span>, <a class="idref" href="classcomp.html#classical_completeness_signature.enum_predicate"><span class="id" type="axiom">enum_predicate</span></a> <span class="id" type="var">p</span> = <a class="idref" href="classcomp.html#classical_completeness_signature.enum_predicate"><span class="id" type="axiom">enum_predicate</span></a> <span class="id" type="var">q</span> → <span class="id" type="var">p</span> = <span class="id" type="var">q</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <a name="classical_completeness_signature.enum_constant0_inj"><span class="id" type="axiom">enum_constant0_inj</span></a> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∀ <span class="id" type="var">p</span> <span class="id" type="var">q</span>, <a class="idref" href="classcomp.html#classical_completeness_signature.enum_constant0"><span class="id" type="axiom">enum_constant0</span></a> <span class="id" type="var">p</span> = <a class="idref" href="classcomp.html#classical_completeness_signature.enum_constant0"><span class="id" type="axiom">enum_constant0</span></a> <span class="id" type="var">q</span> → <span class="id" type="var">p</span> = <span class="id" type="var">q</span>.<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#classical_completeness_signature"><span class="id" type="module">classical_completeness_signature</span></a>.<br/>

<br/>
<span class="id" type="keyword">Module</span> <a name="classical_completeness"><span class="id" type="module">classical_completeness</span></a> (<span class="id" type="var">ccsig</span>:classical_completeness_signature).<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Export</span> <span class="id" type="var">ccsig</span>.<br/>

<br/>
</div>

<div class="doc">

<br/> <br/>
   A formula is then defined using the above. There is a special <span class="inlinecode"><span class="id" type="var">added</span></span> constructor for constants, these are the Henkin constants. There are separate constructors for variables bound by quantifiers <span class="inlinecode"><span class="id" type="var">bvar</span></span>, and free variables <span class="inlinecode"><span class="id" type="var">fvar</span></span>.

</div>
<div class="code">
<span class="id" type="keyword">Inductive</span> <a name="classical_completeness.formula"><span class="id" type="inductive">formula</span></a> : <span class="id" type="keyword">Set</span> :=<br/>
| <a name="classical_completeness.bot"><span class="id" type="constructor">bot</span></a> : <a class="idref" href="classcomp.html#formula"><span class="id" type="inductive">formula</span></a><br/>
| <a name="classical_completeness.imp"><span class="id" type="constructor">imp</span></a> : <a class="idref" href="classcomp.html#formula"><span class="id" type="inductive">formula</span></a> → <a class="idref" href="classcomp.html#formula"><span class="id" type="inductive">formula</span></a> → <a class="idref" href="classcomp.html#formula"><span class="id" type="inductive">formula</span></a><br/>
| <a name="classical_completeness.all"><span class="id" type="constructor">all</span></a> : <a class="idref" href="classcomp.html#formula"><span class="id" type="inductive">formula</span></a> → <a class="idref" href="classcomp.html#formula"><span class="id" type="inductive">formula</span></a><br/>
| <a name="classical_completeness.atom"><span class="id" type="constructor">atom</span></a> : <a class="idref" href="classcomp.html#ccsig.predicate"><span class="id" type="axiom">predicate</span></a> → <a class="idref" href="classcomp.html#term"><span class="id" type="inductive">term</span></a> → <a class="idref" href="classcomp.html#formula"><span class="id" type="inductive">formula</span></a><br/>
<span class="id" type="keyword">with</span> <a name="classical_completeness.term"><span class="id" type="inductive">term</span></a> : <span class="id" type="keyword">Set</span> :=<br/>
| <a name="classical_completeness.bvar"><span class="id" type="constructor">bvar</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="classcomp.html#term"><span class="id" type="inductive">term</span></a><br/>
| <a name="classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="classcomp.html#term"><span class="id" type="inductive">term</span></a><br/>
| <a name="classical_completeness.cnst"><span class="id" type="constructor">cnst</span></a> : <a class="idref" href="classcomp.html#constant"><span class="id" type="inductive">constant</span></a> → <a class="idref" href="classcomp.html#term"><span class="id" type="inductive">term</span></a><br/>
| <a name="classical_completeness.func"><span class="id" type="constructor">func</span></a> : <a class="idref" href="classcomp.html#ccsig.function"><span class="id" type="axiom">function</span></a> → <a class="idref" href="classcomp.html#term"><span class="id" type="inductive">term</span></a> → <a class="idref" href="classcomp.html#term"><span class="id" type="inductive">term</span></a><br/>
<span class="id" type="keyword">with</span> <a name="classical_completeness.constant"><span class="id" type="inductive">constant</span></a> : <span class="id" type="keyword">Set</span> := <br/>
| <a name="classical_completeness.original"><span class="id" type="constructor">original</span></a> : <a class="idref" href="classcomp.html#ccsig.constant0"><span class="id" type="axiom">constant0</span></a> → <a class="idref" href="classcomp.html#constant"><span class="id" type="inductive">constant</span></a><br/>
| <a name="classical_completeness.added"><span class="id" type="constructor">added</span></a> : <a class="idref" href="classcomp.html#formula"><span class="id" type="inductive">formula</span></a> → <a class="idref" href="classcomp.html#constant"><span class="id" type="inductive">constant</span></a>.<br/>

<br/>
</div>

<div class="doc">
'Opening up' quantifiers, i.e. replacing a de Bruijn variable bound
   by a quantifier, by a formula. 
</div>
<div class="code">
<span class="id" type="keyword">Fixpoint</span><br/>
&nbsp;&nbsp;<a name="classical_completeness.open_rec"><span class="id" type="definition">open_rec</span></a> (<span class="id" type="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">u</span> : <a class="idref" href="classcomp.html#classical_completeness.term"><span class="id" type="inductive">term</span></a>) (<span class="id" type="var">t</span> : <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>) {<span class="id" type="keyword">struct</span> <span class="id" type="var">t</span>} : <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a>       ⇒ <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> <span class="id" type="var">t1</span> <span class="id" type="var">t2</span> ⇒ <a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> (<a class="idref" href="classcomp.html#open_rec"><span class="id" type="definition">open_rec</span></a> <span class="id" type="var">k</span> <span class="id" type="var">u</span> <span class="id" type="var">t1</span>) (<a class="idref" href="classcomp.html#open_rec"><span class="id" type="definition">open_rec</span></a> <span class="id" type="var">k</span> <span class="id" type="var">u</span> <span class="id" type="var">t2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">t1</span>    ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> (<a class="idref" href="classcomp.html#open_rec"><span class="id" type="definition">open_rec</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">k</span>) <span class="id" type="var">u</span> <span class="id" type="var">t1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.atom"><span class="id" type="constructor">atom</span></a> <span class="id" type="var">p</span> <span class="id" type="var">t1</span> ⇒ <a class="idref" href="classcomp.html#classical_completeness.atom"><span class="id" type="constructor">atom</span></a> <span class="id" type="var">p</span> (<a class="idref" href="classcomp.html#open_rec_term"><span class="id" type="definition">open_rec_term</span></a> <span class="id" type="var">k</span> <span class="id" type="var">u</span> <span class="id" type="var">t1</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
<span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;<a name="classical_completeness.open_rec_term"><span class="id" type="definition">open_rec_term</span></a> (<span class="id" type="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">u</span> : <a class="idref" href="classcomp.html#classical_completeness.term"><span class="id" type="inductive">term</span></a>) (<span class="id" type="var">t</span> : <a class="idref" href="classcomp.html#classical_completeness.term"><span class="id" type="inductive">term</span></a>) {<span class="id" type="keyword">struct</span> <span class="id" type="var">t</span>} : <a class="idref" href="classcomp.html#classical_completeness.term"><span class="id" type="inductive">term</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.bvar"><span class="id" type="constructor">bvar</span></a> <span class="id" type="var">i</span>    ⇒ <span class="id" type="keyword">if</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Arith.EqNat.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">k</span> <span class="id" type="var">i</span> <span class="id" type="keyword">then</span> <span class="id" type="var">u</span> <span class="id" type="keyword">else</span> (<a class="idref" href="classcomp.html#classical_completeness.bvar"><span class="id" type="constructor">bvar</span></a> <span class="id" type="var">i</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span>    ⇒ <a class="idref" href="classcomp.html#classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.cnst"><span class="id" type="constructor">cnst</span></a> <span class="id" type="var">c</span>    ⇒ <a class="idref" href="classcomp.html#classical_completeness.cnst"><span class="id" type="constructor">cnst</span></a> <span class="id" type="var">c</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.func"><span class="id" type="constructor">func</span></a> <span class="id" type="var">f</span> <span class="id" type="var">t1</span> ⇒ <a class="idref" href="classcomp.html#classical_completeness.func"><span class="id" type="constructor">func</span></a> <span class="id" type="var">f</span> (<a class="idref" href="classcomp.html#open_rec_term"><span class="id" type="definition">open_rec_term</span></a> <span class="id" type="var">k</span> <span class="id" type="var">u</span> <span class="id" type="var">t1</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Substituting the first variable in the term u, by the term t. 
</div>
<div class="code">
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.open"><span class="id" type="definition">open</span></a> <span class="id" type="var">t</span> <span class="id" type="var">u</span> := <a class="idref" href="classcomp.html#classical_completeness.open_rec"><span class="id" type="definition">open_rec</span></a> 0 <span class="id" type="var">u</span> <span class="id" type="var">t</span>.<br/>
<span class="id" type="keyword">Notation</span> "t ^^ u" := (<a class="idref" href="classcomp.html#classical_completeness.open"><span class="id" type="definition">open</span></a> <span class="id" type="var">t</span> <span class="id" type="var">u</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 67).<br/>
<span class="id" type="keyword">Notation</span> "t ^ x" := (<a class="idref" href="classcomp.html#classical_completeness.open"><span class="id" type="definition">open</span></a> <span class="id" type="var">t</span> (<a class="idref" href="classcomp.html#classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span>)).<br/>

<br/>
</div>

<div class="doc">
A formula is <span class="inlinecode"><span class="id" type="var">locl</span></span> (locally closed) when all <span class="inlinecode"><span class="id" type="var">bvar</span></span>-s are bound by quantifiers, but there might well be <span class="inlinecode"><span class="id" type="var">fvar</span></span>-s around. 
</div>
<div class="code">
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<span class="id" type="var">f</span>:formula) := ∀ <span class="id" type="var">n</span> <span class="id" type="var">t</span>, (<a class="idref" href="classcomp.html#classical_completeness.open_rec"><span class="id" type="definition">open_rec</span></a> <span class="id" type="var">n</span> <span class="id" type="var">t</span> <span class="id" type="var">f</span>) = <span class="id" type="var">f</span>.<br/>

<br/>
</div>

<div class="doc">
A term is locally-closed if it simply does not have bound
   variables, but let us define it symmetrically to locl. 
</div>
<div class="code">
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.loclt"><span class="id" type="definition">loclt</span></a> (<span class="id" type="var">t</span>:term) := ∀ <span class="id" type="var">n</span> <span class="id" type="var">t'</span>, (<a class="idref" href="classcomp.html#classical_completeness.open_rec_term"><span class="id" type="definition">open_rec_term</span></a> <span class="id" type="var">n</span> <span class="id" type="var">t'</span> <span class="id" type="var">t</span>) = <span class="id" type="var">t</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.locll"><span class="id" type="definition">locll</span></a> (<span class="id" type="var">Gamma</span>:list <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>) := ∀ <span class="id" type="var">B</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#In"><span class="id" type="definition">In</span></a> <span class="id" type="var">B</span> <span class="id" type="var">Gamma</span> → <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> <span class="id" type="var">B</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.notin"><span class="id" type="definition">notin</span></a> (<span class="id" type="var">x</span>:nat) (<span class="id" type="var">L</span>:list <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) := <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#In"><span class="id" type="definition">In</span></a> <span class="id" type="var">x</span> <span class="id" type="var">L</span>).<br/>
<span class="id" type="keyword">Notation</span> "x \notin L" := (<a class="idref" href="classcomp.html#classical_completeness.notin"><span class="id" type="definition">notin</span></a> <span class="id" type="var">x</span> <span class="id" type="var">L</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 69).<br/>

<br/>
</div>

<div class="doc">
   Natural deduction system for classical predicate logic with cofinite quantification

</div>
<div class="code">
<span class="id" type="keyword">Inductive</span> <a name="classical_completeness.proof"><span class="id" type="inductive">proof</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a> → <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="classical_completeness.bot_elim"><span class="id" type="constructor">bot_elim</span></a>  : ∀ <span class="id" type="var">Gamma</span>, <br/>
&nbsp;&nbsp;<a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a> → ∀ <span class="id" type="var">A</span>, <a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span><br/>
| <a name="classical_completeness.imp_elim"><span class="id" type="constructor">imp_elim</span></a>  : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span>, <br/>
&nbsp;&nbsp;<a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span>) → <a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span> → <a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">B</span><br/>
| <a name="classical_completeness.imp_intro"><span class="id" type="constructor">imp_intro</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span>, <br/>
&nbsp;&nbsp;<a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> (<span class="id" type="var">A</span>::Gamma) <span class="id" type="var">B</span> → <a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span>)<br/>
| <a name="classical_completeness.dneg"><span class="id" type="constructor">dneg</span></a>      : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span>, <br/>
&nbsp;&nbsp;<a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> (<a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> <span class="id" type="var">A</span> <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a>) <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a>) → <a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span><br/>
| <a name="classical_completeness.hypo"><span class="id" type="constructor">hypo</span></a>      : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span>, <br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#In"><span class="id" type="definition">In</span></a> <span class="id" type="var">A</span> <span class="id" type="var">Gamma</span> → <a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span><br/>
| <a name="classical_completeness.all_elim"><span class="id" type="constructor">all_elim</span></a>  : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span>, <br/>
&nbsp;&nbsp;<a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>) → ∀ <span class="id" type="var">t</span>:term, <a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<span class="id" type="var">A</span>^^t)<br/>
| <a name="classical_completeness.all_intro"><span class="id" type="constructor">all_intro</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span> <span class="id" type="var">L</span>, <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>) →<br/>
&nbsp;&nbsp;(∀ <span class="id" type="var">x</span>, <span class="id" type="var">x</span> \notin <span class="id" type="var">L</span> → <a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<span class="id" type="var">A</span>^x)) → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>)<br/>
| <a name="classical_completeness.weaken"><span class="id" type="constructor">weaken</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span>, <a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span> → <a class="idref" href="classcomp.html#proof"><span class="id" type="inductive">proof</span></a> (<span class="id" type="var">B</span>::Gamma) <span class="id" type="var">A</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> "A ⇒ B" := (<a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> <span class="id" type="var">A</span> <span class="id" type="var">B</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 55, <span class="id" type="var">right</span> <span class="id" type="var">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> "'neg' A" := (<a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> <span class="id" type="var">A</span> <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 53, <span class="id" type="var">right</span> <span class="id" type="var">associativity</span>).<br/>

<br/>
</div>

<div class="doc">
A general set of formulas 
</div>
<div class="code">
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.formula_set"><span class="id" type="definition">formula_set</span></a> := <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a> → <span class="id" type="keyword">Prop</span>.<br/>

<br/>
</div>

<div class="doc">
Definition of a "minimal model", one without standard
   interpretation of absurdity 
</div>
<div class="code">
<span class="id" type="keyword">Record</span> <a name="classical_completeness.model"><span class="id" type="record">model</span></a> (<span class="id" type="var">M</span>:formula_set) : <span class="id" type="keyword">Prop</span> := {<br/>
<br/>
&nbsp;&nbsp;<a name="classical_completeness.model_dneg"><span class="id" type="projection">model_dneg</span></a> : ∀ <span class="id" type="var">A</span>, <span class="id" type="var">M</span> (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <span class="id" type="var">A</span> ⇒ <span class="id" type="var">A</span>);<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<a name="classical_completeness.model_imp_faithful1"><span class="id" type="projection">model_imp_faithful1</span></a> : ∀ <span class="id" type="var">A</span> <span class="id" type="var">B</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">M</span> (<span class="id" type="var">A</span> ⇒ <span class="id" type="var">B</span>) → (<span class="id" type="var">M</span> <span class="id" type="var">A</span> → <span class="id" type="var">M</span> <span class="id" type="var">B</span>);<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<a name="classical_completeness.model_imp_faithful2"><span class="id" type="projection">model_imp_faithful2</span></a> : ∀ <span class="id" type="var">A</span> <span class="id" type="var">B</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">M</span> <span class="id" type="var">A</span> → <span class="id" type="var">M</span> <span class="id" type="var">B</span>) → <span class="id" type="var">M</span> (<span class="id" type="var">A</span> ⇒ <span class="id" type="var">B</span>);<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<a name="classical_completeness.model_all_faithful1"><span class="id" type="projection">model_all_faithful1</span></a> : ∀ <span class="id" type="var">A</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">M</span> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>) → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∀ <span class="id" type="var">t</span>:term, <span class="id" type="var">M</span> (<span class="id" type="var">A</span>^^t);<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<a name="classical_completeness.model_all_faithful2"><span class="id" type="projection">model_all_faithful2</span></a> : ∀ <span class="id" type="var">A</span>, <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(∀ <span class="id" type="var">t</span>:term, <a class="idref" href="classcomp.html#classical_completeness.loclt"><span class="id" type="definition">loclt</span></a> <span class="id" type="var">t</span> → <span class="id" type="var">M</span> (<span class="id" type="var">A</span>^^t)) →  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">M</span> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>)<br/>
}.<br/>

<br/>
</div>

<div class="doc">
The definition of a "classical" as opposed to a "minimal" model is
   given, but not used. 
</div>
<div class="code">
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.model_bot_faithful"><span class="id" type="definition">model_bot_faithful</span></a> (<span class="id" type="var">M</span>:formula_set) := <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a> (<span class="id" type="var">M</span> <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a>).<br/>
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.classical_model"><span class="id" type="definition">classical_model</span></a> (<span class="id" type="var">M</span>:formula_set) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.model"><span class="id" type="record">model</span></a> <span class="id" type="var">M</span> ∧ <a class="idref" href="classcomp.html#classical_completeness.model_bot_faithful"><span class="id" type="definition">model_bot_faithful</span></a> <span class="id" type="var">M</span>.<br/>

<br/>
</div>

<div class="doc">
A set of formulas interprets a sequent Gamma|-A if the inclusion of Gamma 
   implies the inclusion of A 
</div>
<div class="code">
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.interprets"><span class="id" type="definition">interprets</span></a> (<span class="id" type="var">M</span>:formula_set)(Gamma:list <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>)(<span class="id" type="var">A</span>:formula) :=<br/>
&nbsp;&nbsp;(∀ <span class="id" type="var">f</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#In"><span class="id" type="definition">In</span></a> <span class="id" type="var">f</span> <span class="id" type="var">Gamma</span> → <span class="id" type="var">M</span> <span class="id" type="var">f</span>) → <span class="id" type="var">M</span> <span class="id" type="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
A sequent is valid if it is true in all models 
</div>
<div class="code">
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.valid"><span class="id" type="definition">valid</span></a> (<span class="id" type="var">Gamma</span>:list <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>)(<span class="id" type="var">A</span>:formula) := <br/>
&nbsp;&nbsp;∀ <span class="id" type="var">M</span>, <a class="idref" href="classcomp.html#classical_completeness.model"><span class="id" type="record">model</span></a> <span class="id" type="var">M</span> → <a class="idref" href="classcomp.html#classical_completeness.interprets"><span class="id" type="definition">interprets</span></a> <span class="id" type="var">M</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span>.<br/>

<br/>
<span class="id" type="keyword">Section</span> <a name="classical_completeness.natural_deduction_lemmas"><span class="id" type="section">natural_deduction_lemmas</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.peirce"><span class="id" type="lemma">peirce</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>, <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (((<span class="id" type="var">P</span> ⇒ <span class="id" type="var">Q</span>) ⇒ <span class="id" type="var">P</span>) ⇒ <span class="id" type="var">P</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.proof_imp_trans"><span class="id" type="lemma">proof_imp_trans</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<span class="id" type="var">x</span> ⇒ <span class="id" type="var">y</span>) → <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<span class="id" type="var">y</span> ⇒ <span class="id" type="var">z</span>) → <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<span class="id" type="var">x</span> ⇒ <span class="id" type="var">z</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.proof_imp_contrapos"><span class="id" type="lemma">proof_imp_contrapos</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<span class="id" type="var">x</span> ⇒ <span class="id" type="var">y</span>) → <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <span class="id" type="var">y</span> ⇒ <a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <span class="id" type="var">x</span>).<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#classical_completeness.natural_deduction_lemmas"><span class="id" type="section">natural_deduction_lemmas</span></a>.<br/>

<br/>
</div>

<div class="doc">
Some tactics used for building the Lindenbaum algebra below 
</div>
<div class="code">
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">impi</span> := <span class="id" type="tactic">apply</span> <a class="idref" href="classcomp.html#classical_completeness.imp_intro"><span class="id" type="constructor">imp_intro</span></a>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">impe</span> := <span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="tactic">apply</span> <a class="idref" href="classcomp.html#classical_completeness.imp_elim"><span class="id" type="constructor">imp_elim</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">dneg</span> := <span class="id" type="tactic">apply</span> <a class="idref" href="classcomp.html#classical_completeness.dneg"><span class="id" type="constructor">dneg</span></a>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">hypo</span> := <span class="id" type="tactic">apply</span> <a class="idref" href="classcomp.html#classical_completeness.hypo"><span class="id" type="constructor">hypo</span></a>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">auto</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">weak</span> := <span class="id" type="tactic">apply</span> <a class="idref" href="classcomp.html#classical_completeness.weaken"><span class="id" type="constructor">weaken</span></a>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">tran</span> := <span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="tactic">apply</span> <a class="idref" href="classcomp.html#classical_completeness.proof_imp_trans"><span class="id" type="lemma">proof_imp_trans</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span>.<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">contra</span> := <span class="id" type="tactic">apply</span> <a class="idref" href="classcomp.html#classical_completeness.proof_imp_contrapos"><span class="id" type="lemma">proof_imp_contrapos</span></a>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.formula_dec"><span class="id" type="lemma">formula_dec</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>:formula, {<span class="id" type="var">x</span> = <span class="id" type="var">y</span>}+{x ≠ <span class="id" type="var">y</span>}.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.constant_dec"><span class="id" type="lemma">constant_dec</span></a> : ∀ <span class="id" type="var">f1</span> <span class="id" type="var">f2</span>:constant, {<span class="id" type="var">f1</span> = <span class="id" type="var">f2</span>} + {<span class="id" type="var">f1</span> ≠ <span class="id" type="var">f2</span>}.<br/>

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="keyword">Export</span> <a name="CBAproof"><span class="id" type="module">CBAproof</span></a> &lt;: <a class="idref" href="filters.html#"><span class="id" type="module">CBA</span></a>.<br/>

<br/>
</div>

<div class="doc">
The Lindenbaum Boolean algebra which will be used in the model
   existence lemma to build a maximal consistent extension of a set of
   formulas. (the "Universal model") 
</div>
<div class="code">
<span class="id" type="keyword">Section</span> <a name="classical_completeness.CBAproof.boolean_algebra"><span class="id" type="section">boolean_algebra</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Let</span> <a name="classical_completeness.CBAproof.B"><span class="id" type="definition">B</span></a> := <a class="idref" href="classcomp.html#classical_completeness.CBAproof.formula"><span class="id" type="inductive">formula</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.compl"><span class="id" type="definition">compl</span></a> : <span class="id" type="var">B</span> → <span class="id" type="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> : <span class="id" type="var">B</span> → <span class="id" type="var">B</span> → <span class="id" type="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> : <span class="id" type="var">B</span> → <span class="id" type="var">B</span> → <span class="id" type="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.top"><span class="id" type="definition">top</span></a> : <span class="id" type="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.eq_B"><span class="id" type="definition">eq_B</span></a> (<span class="id" type="var">x</span> <span class="id" type="var">y</span>:B): <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(∃ <span class="id" type="var">p</span>:proof <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#nil"><span class="id" type="constructor">nil</span></a> (<span class="id" type="var">x</span> ⇒ <span class="id" type="var">y</span>), <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∧ (∃ <span class="id" type="var">p</span>:proof <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#nil"><span class="id" type="constructor">nil</span></a> (<span class="id" type="var">y</span> ⇒ <span class="id" type="var">x</span>), <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="classical_completeness.CBAproof.eq_B_refl"><span class="id" type="lemma">eq_B_refl</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Relations.Relation_Definitions.html#reflexive"><span class="id" type="definition">reflexive</span></a> <span class="id" type="var">B</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B"><span class="id" type="definition">eq_B</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="classical_completeness.CBAproof.eq_B_symm"><span class="id" type="lemma">eq_B_symm</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Relations.Relation_Definitions.html#symmetric"><span class="id" type="definition">symmetric</span></a> <span class="id" type="var">B</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B"><span class="id" type="definition">eq_B</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="classical_completeness.CBAproof.eq_B_trans"><span class="id" type="lemma">eq_B_trans</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Relations.Relation_Definitions.html#transitive"><span class="id" type="definition">transitive</span></a> <span class="id" type="var">B</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B"><span class="id" type="definition">eq_B</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Notation</span> "x == y" := (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B"><span class="id" type="definition">eq_B</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 70, <span class="id" type="var">no</span> <span class="id" type="var">associativity</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Add</span> <span class="id" type="var">Relation</span> <span class="id" type="var">B</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B"><span class="id" type="definition">eq_B</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span> <span class="id" type="var">proved</span> <span class="id" type="tactic">by</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B_refl"><span class="id" type="lemma">eq_B_refl</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">symmetry</span> <span class="id" type="var">proved</span> <span class="id" type="tactic">by</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B_symm"><span class="id" type="lemma">eq_B_symm</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">transitivity</span> <span class="id" type="var">proved</span> <span class="id" type="tactic">by</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B_trans"><span class="id" type="lemma">eq_B_trans</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">as</span> <span class="id" type="var">eq_B_relation</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Add</span> <span class="id" type="var">Morphism</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">signature</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B"><span class="id" type="definition">eq_B</span></a> ⇒ <a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B"><span class="id" type="definition">eq_B</span></a> ⇒ <a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B"><span class="id" type="definition">eq_B</span></a> <span class="id" type="keyword">as</span> <span class="id" type="var">join_morphism</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Add</span> <span class="id" type="var">Morphism</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">signature</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B"><span class="id" type="definition">eq_B</span></a> ⇒ <a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B"><span class="id" type="definition">eq_B</span></a> ⇒ <a class="idref" href="classcomp.html#classical_completeness.CBAproof.eq_B"><span class="id" type="definition">eq_B</span></a> <span class="id" type="keyword">as</span> <span class="id" type="var">meet_morphism</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.id_B_dec"><span class="id" type="lemma">id_B_dec</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">B</span>, {<span class="id" type="var">x</span> = <span class="id" type="var">y</span>}+{x ≠ <span class="id" type="var">y</span>}.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.id_B_dec_right"><span class="id" type="lemma">id_B_dec_right</span></a> : ∀ (<span class="id" type="var">x</span> <span class="id" type="var">y</span>:B), <span class="id" type="var">x</span>&lt;&gt;y → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∃ <span class="id" type="var">H</span>:x&lt;&gt;y, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.id_B_dec"><span class="id" type="lemma">id_B_dec</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Specif.html#right"><span class="id" type="constructor">right</span></a> (<span class="id" type="var">x</span>=y) <span class="id" type="var">H</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.id_B_dec_left"><span class="id" type="lemma">id_B_dec_left</span></a> : ∀ <span class="id" type="var">x</span>:B, ∃ <span class="id" type="var">H</span>:x=x, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.CBAproof.id_B_dec"><span class="id" type="lemma">id_B_dec</span></a> <span class="id" type="var">x</span> <span class="id" type="var">x</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Specif.html#left"><span class="id" type="constructor">left</span></a> (<span class="id" type="var">x</span>&lt;&gt;x) <span class="id" type="var">H</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.join_idem"><span class="id" type="lemma">join_idem</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">x</span> == <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.meet_idem"><span class="id" type="lemma">meet_idem</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">x</span> == <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.join_comm"><span class="id" type="lemma">join_comm</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> == <a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <span class="id" type="var">y</span> <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.meet_comm"><span class="id" type="lemma">meet_comm</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> == <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">y</span> <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.join_assoc"><span class="id" type="lemma">join_assoc</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <span class="id" type="var">x</span> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <span class="id" type="var">y</span> <span class="id" type="var">z</span>) == <a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) <span class="id" type="var">z</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.meet_assoc"><span class="id" type="lemma">meet_assoc</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">x</span> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">y</span> <span class="id" type="var">z</span>) == <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) <span class="id" type="var">z</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.meet_absorb"><span class="id" type="lemma">meet_absorb</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">x</span> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) == <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.join_absorb"><span class="id" type="lemma">join_absorb</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <span class="id" type="var">x</span> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) == <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.join_distrib"><span class="id" type="lemma">join_distrib</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) <span class="id" type="var">z</span> == <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">z</span>) (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <span class="id" type="var">y</span> <span class="id" type="var">z</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.meet_bott"><span class="id" type="lemma">meet_bott</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.bot"><span class="id" type="constructor">bot</span></a> <span class="id" type="var">x</span> == <a class="idref" href="classcomp.html#classical_completeness.CBAproof.bot"><span class="id" type="constructor">bot</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.join_bott"><span class="id" type="lemma">join_bott</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.bot"><span class="id" type="constructor">bot</span></a> <span class="id" type="var">x</span> == <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.meet_top"><span class="id" type="lemma">meet_top</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.top"><span class="id" type="definition">top</span></a> <span class="id" type="var">x</span> == <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.join_top"><span class="id" type="lemma">join_top</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.top"><span class="id" type="definition">top</span></a> <span class="id" type="var">x</span> == <a class="idref" href="classcomp.html#classical_completeness.CBAproof.top"><span class="id" type="definition">top</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.meet_compl"><span class="id" type="lemma">meet_compl</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">x</span> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.compl"><span class="id" type="definition">compl</span></a> <span class="id" type="var">x</span>) == <a class="idref" href="classcomp.html#classical_completeness.CBAproof.bot"><span class="id" type="constructor">bot</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.join_compl"><span class="id" type="lemma">join_compl</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <span class="id" type="var">x</span> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.compl"><span class="id" type="definition">compl</span></a> <span class="id" type="var">x</span>) == <a class="idref" href="classcomp.html#classical_completeness.CBAproof.top"><span class="id" type="definition">top</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.CBAproof.meet_distrib"><span class="id" type="lemma">meet_distrib</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) <span class="id" type="var">z</span> == <a class="idref" href="classcomp.html#classical_completeness.CBAproof.join"><span class="id" type="definition">join</span></a> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">z</span>) (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">y</span> <span class="id" type="var">z</span>).<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.boolean_algebra"><span class="id" type="section">boolean_algebra</span></a>.<br/>

<br/>
</div>

<div class="doc">
To use the completion of filters from filters.v, we also need an
enumeration of the elements of the Boolean algebra, which is achieved
by borrowing code about the Cantor pairing function from Russell
O'Connor's formalisation of the incompleteness theorem 
</div>
<div class="code">
<span class="id" type="keyword">Section</span> <a name="classical_completeness.CBAproof.Enumeration"><span class="id" type="section">Enumeration</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Add</span> <span class="id" type="var">LoadPath</span> "pairing".<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="library">cPair</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.enump"><span class="id" type="definition">enump</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">p</span> ⇒ <span class="id" type="definition">cPair</span> 11 (<a class="idref" href="classcomp.html#ccsig.enum_predicate"><span class="id" type="axiom">enum_predicate</span></a> <span class="id" type="var">p</span>).<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.enumc0"><span class="id" type="definition">enumc0</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">c</span> ⇒ <span class="id" type="definition">cPair</span> 12 (<a class="idref" href="classcomp.html#ccsig.enum_constant0"><span class="id" type="axiom">enum_constant0</span></a> <span class="id" type="var">c</span>).<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.enumfunc"><span class="id" type="definition">enumfunc</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">f</span> ⇒ <span class="id" type="definition">cPair</span> 13 (<a class="idref" href="classcomp.html#ccsig.enum_function"><span class="id" type="axiom">enum_function</span></a> <span class="id" type="var">f</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span> <a name="classical_completeness.CBAproof.enumf"><span class="id" type="definition">enumf</span></a> (<span class="id" type="var">f</span>:formula) : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">f</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.atom"><span class="id" type="constructor">atom</span></a> <span class="id" type="var">p</span> <span class="id" type="var">t</span>) ⇒ <span class="id" type="definition">cPair</span> 1 (<span class="id" type="definition">cPair</span> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.enump"><span class="id" type="definition">enump</span></a> <span class="id" type="var">p</span>) (<a class="idref" href="classcomp.html#enumt"><span class="id" type="definition">enumt</span></a> <span class="id" type="var">t</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">g</span>) ⇒ <span class="id" type="definition">cPair</span> 2 (<a class="idref" href="classcomp.html#enumf"><span class="id" type="definition">enumf</span></a> <span class="id" type="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.imp"><span class="id" type="constructor">imp</span></a> <span class="id" type="var">g</span> <span class="id" type="var">h</span>) ⇒ <span class="id" type="definition">cPair</span> 3 (<span class="id" type="definition">cPair</span> (<a class="idref" href="classcomp.html#enumf"><span class="id" type="definition">enumf</span></a> <span class="id" type="var">g</span>) (<a class="idref" href="classcomp.html#enumf"><span class="id" type="definition">enumf</span></a> <span class="id" type="var">h</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.CBAproof.bot"><span class="id" type="constructor">bot</span></a> ⇒ 4<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">with</span> <a name="classical_completeness.CBAproof.enumt"><span class="id" type="definition">enumt</span></a> (<span class="id" type="var">t</span>:term) : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.func"><span class="id" type="constructor">func</span></a> <span class="id" type="var">phi</span> <span class="id" type="var">t'</span>) ⇒ <span class="id" type="definition">cPair</span> 5 (<span class="id" type="definition">cPair</span> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.enumfunc"><span class="id" type="definition">enumfunc</span></a> <span class="id" type="var">phi</span>) (<a class="idref" href="classcomp.html#enumt"><span class="id" type="definition">enumt</span></a> <span class="id" type="var">t'</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.cnst"><span class="id" type="constructor">cnst</span></a> <span class="id" type="var">c</span>) ⇒ <span class="id" type="definition">cPair</span> 6 (<a class="idref" href="classcomp.html#enumc"><span class="id" type="definition">enumc</span></a> <span class="id" type="var">c</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span>) ⇒ <span class="id" type="definition">cPair</span> 7 <span class="id" type="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.bvar"><span class="id" type="constructor">bvar</span></a> <span class="id" type="var">x</span>) ⇒ <span class="id" type="definition">cPair</span> 8 <span class="id" type="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">with</span> <a name="classical_completeness.CBAproof.enumc"><span class="id" type="definition">enumc</span></a> (<span class="id" type="var">c</span>:constant) : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">c</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.added"><span class="id" type="constructor">added</span></a> <span class="id" type="var">x</span>) ⇒ <span class="id" type="definition">cPair</span> 9 (<a class="idref" href="classcomp.html#enumf"><span class="id" type="definition">enumf</span></a> <span class="id" type="var">x</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.original"><span class="id" type="constructor">original</span></a> <span class="id" type="var">x</span>) ⇒ <span class="id" type="definition">cPair</span> 10 (<a class="idref" href="classcomp.html#classical_completeness.CBAproof.enumc0"><span class="id" type="definition">enumc0</span></a> <span class="id" type="var">x</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Scheme</span> <span class="id" type="keyword">Induction</span> <span class="id" type="keyword">for</span> <span class="id" type="var">formula</span> <span class="id" type="keyword">Sort</span> <span class="id" type="keyword">Prop</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">with</span> <span class="id" type="keyword">Induction</span> <span class="id" type="keyword">for</span> <span class="id" type="var">term</span> <span class="id" type="keyword">Sort</span> <span class="id" type="keyword">Prop</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">with</span> <span class="id" type="keyword">Induction</span> <span class="id" type="keyword">for</span> <span class="id" type="var">constant</span> <span class="id" type="keyword">Sort</span> <span class="id" type="keyword">Prop</span>.<br/>

<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="classical_completeness.CBAproof.countable_ftc"><span class="id" type="lemma">countable_ftc</span></a> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(∀ <span class="id" type="var">f</span> <span class="id" type="var">g</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.enumf"><span class="id" type="definition">enumf</span></a> <span class="id" type="var">f</span> = <a class="idref" href="classcomp.html#classical_completeness.CBAproof.enumf"><span class="id" type="definition">enumf</span></a> <span class="id" type="var">g</span> → <span class="id" type="var">f</span> = <span class="id" type="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;∧ (∀ <span class="id" type="var">t</span> <span class="id" type="var">s</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.enumt"><span class="id" type="definition">enumt</span></a> <span class="id" type="var">t</span> = <a class="idref" href="classcomp.html#classical_completeness.CBAproof.enumt"><span class="id" type="definition">enumt</span></a> <span class="id" type="var">s</span> → <span class="id" type="var">t</span> = <span class="id" type="var">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;∧ (∀ <span class="id" type="var">c</span> <span class="id" type="var">k</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.enumc"><span class="id" type="definition">enumc</span></a> <span class="id" type="var">c</span> = <a class="idref" href="classcomp.html#classical_completeness.CBAproof.enumc"><span class="id" type="definition">enumc</span></a> <span class="id" type="var">k</span> → <span class="id" type="var">c</span> = <span class="id" type="var">k</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.enum"><span class="id" type="definition">enum</span></a> := <a class="idref" href="classcomp.html#classical_completeness.CBAproof.enumf"><span class="id" type="definition">enumf</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.countable"><span class="id" type="definition">countable</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <a class="idref" href="classcomp.html#classical_completeness.CBAproof.enum"><span class="id" type="definition">enum</span></a> <span class="id" type="var">x</span> = <a class="idref" href="classcomp.html#classical_completeness.CBAproof.enum"><span class="id" type="definition">enum</span></a> <span class="id" type="var">y</span> → <span class="id" type="var">x</span> = <span class="id" type="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#proj1"><span class="id" type="lemma">proj1</span></a> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.countable_ftc"><span class="id" type="lemma">countable_ftc</span></a>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.Enumeration"><span class="id" type="section">Enumeration</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.eq_B_join_morph"><span class="id" type="definition">eq_B_join_morph</span></a> := <a class="idref" href="classcomp.html#classical_completeness.CBAproof.join_morphism_Morphism"><span class="id" type="instance">join_morphism_Morphism</span></a>.<br/>
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.eq_B_meet_morph"><span class="id" type="definition">eq_B_meet_morph</span></a> := <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet_morphism_Morphism"><span class="id" type="instance">meet_morphism_Morphism</span></a>.<br/>
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.bott"><span class="id" type="definition">bott</span></a> := <a class="idref" href="classcomp.html#classical_completeness.CBAproof.bot"><span class="id" type="constructor">bot</span></a>.<br/>
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.CBAproof.B"><span class="id" type="definition">B</span></a> := <a class="idref" href="classcomp.html#classical_completeness.CBAproof.formula"><span class="id" type="inductive">formula</span></a>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#CBAproof"><span class="id" type="module">CBAproof</span></a>.<br/>

<br/>
</div>

<div class="doc">
Various lemmas that have to do with general lists or their
   interaction with proofs 
</div>
<div class="code">
<span class="id" type="keyword">Section</span> <a name="classical_completeness.list_proof_lemmas"><span class="id" type="section">list_proof_lemmas</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.included"><span class="id" type="definition">included</span></a> (<span class="id" type="var">Gamma</span>:list <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>)(<span class="id" type="var">T</span>:formula_set) := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∀ <span class="id" type="var">f</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#In"><span class="id" type="definition">In</span></a> <span class="id" type="var">f</span> <span class="id" type="var">Gamma</span> → <span class="id" type="var">T</span> <span class="id" type="var">f</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.nil_included"><span class="id" type="lemma">nil_included</span></a> : ∀ <span class="id" type="var">Ax</span>, <a class="idref" href="classcomp.html#classical_completeness.included"><span class="id" type="definition">included</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#nil"><span class="id" type="constructor">nil</span></a> <span class="id" type="var">Ax</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.nil_lem1"><span class="id" type="lemma">nil_lem1</span></a> : ∀ <span class="id" type="var">l</span>:list <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#incl"><span class="id" type="definition">incl</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#nil"><span class="id" type="constructor">nil</span></a> <span class="id" type="var">l</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.included_lem1"><span class="id" type="lemma">included_lem1</span></a> : ∀ <span class="id" type="var">l1</span> <span class="id" type="var">l2</span>:list <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>, ∀ <span class="id" type="var">Ax</span>:formula_set,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.included"><span class="id" type="definition">included</span></a> <span class="id" type="var">l1</span> <span class="id" type="var">Ax</span> → <a class="idref" href="classcomp.html#classical_completeness.included"><span class="id" type="definition">included</span></a> <span class="id" type="var">l2</span> <span class="id" type="var">Ax</span> → <a class="idref" href="classcomp.html#classical_completeness.included"><span class="id" type="definition">included</span></a> (<span class="id" type="var">l1</span>++l2) <span class="id" type="var">Ax</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.weaken_lem1"><span class="id" type="lemma">weaken_lem1</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">Delta</span> <span class="id" type="var">A</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#incl"><span class="id" type="definition">incl</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">Delta</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span> → <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Delta</span> <span class="id" type="var">A</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#classical_completeness.list_proof_lemmas"><span class="id" type="section">list_proof_lemmas</span></a>.<br/>

<br/>
</div>

<div class="doc">
A couple of lemmas about locally closed formulas 
</div>
<div class="code">
<span class="id" type="keyword">Section</span> <a name="classical_completeness.locl_lemmas"><span class="id" type="section">locl_lemmas</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.locl_all_neg"><span class="id" type="lemma">locl_all_neg</span></a> : ∀ <span class="id" type="var">A</span>, <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>) → <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <span class="id" type="var">A</span>)).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.locl_henkin"><span class="id" type="lemma">locl_henkin</span></a> : ∀ <span class="id" type="var">A</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>) → <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> (<span class="id" type="var">A</span> ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>)).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.locl_henkin_neg"><span class="id" type="lemma">locl_henkin_neg</span></a> : ∀ <span class="id" type="var">A</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>) → <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> (<span class="id" type="var">A</span> ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>))).<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#classical_completeness.locl_lemmas"><span class="id" type="section">locl_lemmas</span></a>.<br/>

<br/>
</div>

<div class="doc">
This section defines a fixpoint <span class="inlinecode"><span class="id" type="var">c_appears</span></span> which determines if a
   given constant appears in the formula and then goes on to prove
   that <span class="inlinecode"><span class="id" type="var">c_appears</span> <span class="id" type="var">f</span> (<span class="id" type="var">added</span> (<span class="id" type="var">all</span> <span class="id" type="var">f</span>)) = <span class="id" type="var">false</span></span>, i.e. that a formula
   cannot contain an added (Henkin) constant indexed by itself. This
   is obvious, but the proof has to go on the induction of the depth
   of the formula.

<br/> <br/>
   Another fixpoint <span class="inlinecode"><span class="id" type="var">added_cnsts</span></span> is also defined, to check if a
   formula contains _any_ added constants and is connected to
   <span class="inlinecode"><span class="id" type="var">c_appears</span></span>.

</div>
<div class="code">
<span class="id" type="keyword">Section</span> <a name="classical_completeness.constants_in_formulas"><span class="id" type="section">constants_in_formulas</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span> <a name="classical_completeness.c_appears"><span class="id" type="definition">c_appears</span></a> (<span class="id" type="var">t</span>:formula)(c:constant) {<span class="id" type="keyword">struct</span> <span class="id" type="var">t</span>} : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a>       ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> <span class="id" type="var">t1</span> <span class="id" type="var">t2</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#orb"><span class="id" type="definition">orb</span></a> (<a class="idref" href="classcomp.html#c_appears"><span class="id" type="definition">c_appears</span></a> <span class="id" type="var">t1</span> <span class="id" type="var">c</span>) (<a class="idref" href="classcomp.html#c_appears"><span class="id" type="definition">c_appears</span></a> <span class="id" type="var">t2</span> <span class="id" type="var">c</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">t1</span>    ⇒ <a class="idref" href="classcomp.html#c_appears"><span class="id" type="definition">c_appears</span></a> <span class="id" type="var">t1</span> <span class="id" type="var">c</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.atom"><span class="id" type="constructor">atom</span></a> <span class="id" type="var">p</span> <span class="id" type="var">t1</span> ⇒ <a class="idref" href="classcomp.html#c_appears_term"><span class="id" type="definition">c_appears_term</span></a> <span class="id" type="var">t1</span> <span class="id" type="var">c</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="classical_completeness.c_appears_term"><span class="id" type="definition">c_appears_term</span></a> (<span class="id" type="var">t</span>:term)(c:constant) {<span class="id" type="keyword">struct</span> <span class="id" type="var">t</span>} : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.bvar"><span class="id" type="constructor">bvar</span></a> <span class="id" type="var">i</span>    ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span>    ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.cnst"><span class="id" type="constructor">cnst</span></a> <span class="id" type="var">k</span>    ⇒ <span class="id" type="keyword">if</span> (<a class="idref" href="classcomp.html#classical_completeness.constant_dec"><span class="id" type="lemma">constant_dec</span></a> <span class="id" type="var">k</span> <span class="id" type="var">c</span>) <span class="id" type="keyword">then</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.func"><span class="id" type="constructor">func</span></a> <span class="id" type="var">f</span> <span class="id" type="var">t1</span> ⇒ <a class="idref" href="classcomp.html#c_appears_term"><span class="id" type="definition">c_appears_term</span></a> <span class="id" type="var">t1</span> <span class="id" type="var">c</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
c_appears applied to a list 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span> <a name="classical_completeness.c_appears_l"><span class="id" type="definition">c_appears_l</span></a> (<span class="id" type="var">l</span>:list <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>)(<span class="id" type="var">c</span>:constant) {<span class="id" type="keyword">struct</span> <span class="id" type="var">l</span>} : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">x</span> <span class="id" type="var">x0</span>) ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#orb"><span class="id" type="definition">orb</span></a> (<a class="idref" href="classcomp.html#classical_completeness.c_appears"><span class="id" type="definition">c_appears</span></a> <span class="id" type="var">x</span> <span class="id" type="var">c</span>) (<a class="idref" href="classcomp.html#c_appears_l"><span class="id" type="definition">c_appears_l</span></a> <span class="id" type="var">x0</span> <span class="id" type="var">c</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#nil"><span class="id" type="constructor">nil</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span> <a name="classical_completeness.depth"><span class="id" type="definition">depth</span></a> (<span class="id" type="var">f</span>:formula) : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">f</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.atom"><span class="id" type="constructor">atom</span></a> <span class="id" type="var">p</span> <span class="id" type="var">t</span>) ⇒ <a class="idref" href="classcomp.html#depth_term"><span class="id" type="definition">depth_term</span></a> <span class="id" type="var">t</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">g</span>) ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="classcomp.html#depth"><span class="id" type="definition">depth</span></a> <span class="id" type="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> <span class="id" type="var">g</span> <span class="id" type="var">h</span>) ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Arith.Max.html#max"><span class="id" type="definition">max</span></a> (<a class="idref" href="classcomp.html#depth"><span class="id" type="definition">depth</span></a> <span class="id" type="var">g</span>) (<a class="idref" href="classcomp.html#depth"><span class="id" type="definition">depth</span></a> <span class="id" type="var">h</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a> ⇒ 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="classical_completeness.depth_term"><span class="id" type="definition">depth_term</span></a> (<span class="id" type="var">t</span>:term) : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.func"><span class="id" type="constructor">func</span></a> <span class="id" type="var">f</span> <span class="id" type="var">t'</span>) ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="classcomp.html#depth_term"><span class="id" type="definition">depth_term</span></a> <span class="id" type="var">t'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.cnst"><span class="id" type="constructor">cnst</span></a> <span class="id" type="var">c</span>) ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">c</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.original"><span class="id" type="constructor">original</span></a> <span class="id" type="var">k</span> ⇒ 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> <span class="id" type="var">f</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="classcomp.html#depth"><span class="id" type="definition">depth</span></a> <span class="id" type="var">f</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span>) ⇒ 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.bvar"><span class="id" type="constructor">bvar</span></a> <span class="id" type="var">x</span>) ⇒ 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.bb'''"><span class="id" type="lemma">bb'''</span></a> : ∀ <span class="id" type="var">f</span> <span class="id" type="var">g</span>, <a class="idref" href="classcomp.html#classical_completeness.depth"><span class="id" type="definition">depth</span></a> <span class="id" type="var">f</span> ≤ <a class="idref" href="classcomp.html#classical_completeness.depth"><span class="id" type="definition">depth</span></a> <span class="id" type="var">g</span> → <a class="idref" href="classcomp.html#classical_completeness.c_appears"><span class="id" type="definition">c_appears</span></a> <span class="id" type="var">f</span> (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> <span class="id" type="var">g</span>) = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="classical_completeness.c_appears_thm"><span class="id" type="lemma">c_appears_thm</span></a> : ∀ <span class="id" type="var">f</span>, <a class="idref" href="classcomp.html#classical_completeness.c_appears"><span class="id" type="definition">c_appears</span></a> <span class="id" type="var">f</span> (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">f</span>)) = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.c_appears_l_app"><span class="id" type="lemma">c_appears_l_app</span></a> : ∀ <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> <span class="id" type="var">c</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.c_appears_l"><span class="id" type="definition">c_appears_l</span></a> <span class="id" type="var">l1</span> <span class="id" type="var">c</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> ∧ <a class="idref" href="classcomp.html#classical_completeness.c_appears_l"><span class="id" type="definition">c_appears_l</span></a> <span class="id" type="var">l2</span> <span class="id" type="var">c</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.c_appears_l"><span class="id" type="definition">c_appears_l</span></a> (<span class="id" type="var">l1</span>++l2) <span class="id" type="var">c</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span> <a name="classical_completeness.added_cnsts"><span class="id" type="definition">added_cnsts</span></a> (<span class="id" type="var">t</span>:term) : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.func"><span class="id" type="constructor">func</span></a> <span class="id" type="var">f</span> <span class="id" type="var">t'</span>) ⇒ <a class="idref" href="classcomp.html#added_cnsts"><span class="id" type="definition">added_cnsts</span></a> <span class="id" type="var">t'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.cnst"><span class="id" type="constructor">cnst</span></a> <span class="id" type="var">c</span>) ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">c</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> <span class="id" type="var">k</span>) ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.original"><span class="id" type="constructor">original</span></a> <span class="id" type="var">k</span>) ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span>) ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.bvar"><span class="id" type="constructor">bvar</span></a> <span class="id" type="var">x</span>) ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span> <a name="classical_completeness.added_cnsts_f"><span class="id" type="definition">added_cnsts_f</span></a> (<span class="id" type="var">f</span>:formula) : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">f</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.atom"><span class="id" type="constructor">atom</span></a> <span class="id" type="var">p</span> <span class="id" type="var">t</span>) ⇒ <a class="idref" href="classcomp.html#classical_completeness.added_cnsts"><span class="id" type="definition">added_cnsts</span></a> <span class="id" type="var">t</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">g</span>) ⇒ <a class="idref" href="classcomp.html#added_cnsts_f"><span class="id" type="definition">added_cnsts_f</span></a> <span class="id" type="var">g</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> <span class="id" type="var">g</span> <span class="id" type="var">h</span>) ⇒ <a class="idref" href="classcomp.html#added_cnsts_f"><span class="id" type="definition">added_cnsts_f</span></a> <span class="id" type="var">g</span> || <a class="idref" href="classcomp.html#added_cnsts_f"><span class="id" type="definition">added_cnsts_f</span></a> <span class="id" type="var">h</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.added_cnsts_c_appears"><span class="id" type="lemma">added_cnsts_c_appears</span></a> : ∀ <span class="id" type="var">t</span> <span class="id" type="var">k</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.added_cnsts"><span class="id" type="definition">added_cnsts</span></a> <span class="id" type="var">t</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> → <a class="idref" href="classcomp.html#classical_completeness.c_appears_term"><span class="id" type="definition">c_appears_term</span></a> <span class="id" type="var">t</span> (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> <span class="id" type="var">k</span>) = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.added_cnsts_c_appears'"><span class="id" type="lemma">added_cnsts_c_appears'</span></a> : ∀ <span class="id" type="var">f</span> <span class="id" type="var">g</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.added_cnsts_f"><span class="id" type="definition">added_cnsts_f</span></a> <span class="id" type="var">f</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> → <a class="idref" href="classcomp.html#classical_completeness.c_appears"><span class="id" type="definition">c_appears</span></a> <span class="id" type="var">f</span> (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> <span class="id" type="var">g</span>) = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#classical_completeness.constants_in_formulas"><span class="id" type="section">constants_in_formulas</span></a>.<br/>

<br/>
</div>

<div class="doc">
This section provides that if there is a derivation Gamma |- A,
   then there is a derivation Gamma{x/c} |- A{x/c}, where {x/c} is a
   substitution of the constant c by the free variable x. This lemma
   is needed in <span class="inlinecode"><span class="id" type="var">henkin_equiconsistent</span></span>.  

</div>
<div class="code">
<span class="id" type="keyword">Section</span> <a name="classical_completeness.vanDalen_thm283"><span class="id" type="section">vanDalen_thm283</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="classical_completeness.c2t"><span class="id" type="definition">c2t</span></a> (<span class="id" type="var">t</span>:formula)(c:constant)(x:term)  {<span class="id" type="keyword">struct</span> <span class="id" type="var">t</span>} : <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a>       ⇒ <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> <span class="id" type="var">t1</span> <span class="id" type="var">t2</span> ⇒ <a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> (<a class="idref" href="classcomp.html#c2t"><span class="id" type="definition">c2t</span></a> <span class="id" type="var">t1</span> <span class="id" type="var">c</span> <span class="id" type="var">x</span>) (<a class="idref" href="classcomp.html#c2t"><span class="id" type="definition">c2t</span></a> <span class="id" type="var">t2</span> <span class="id" type="var">c</span> <span class="id" type="var">x</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">t1</span>    ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> (<a class="idref" href="classcomp.html#c2t"><span class="id" type="definition">c2t</span></a> <span class="id" type="var">t1</span> <span class="id" type="var">c</span> <span class="id" type="var">x</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.atom"><span class="id" type="constructor">atom</span></a> <span class="id" type="var">p</span> <span class="id" type="var">t1</span> ⇒ <a class="idref" href="classcomp.html#classical_completeness.atom"><span class="id" type="constructor">atom</span></a> <span class="id" type="var">p</span> (<a class="idref" href="classcomp.html#c2t_term"><span class="id" type="definition">c2t_term</span></a> <span class="id" type="var">t1</span> <span class="id" type="var">c</span> <span class="id" type="var">x</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="classical_completeness.c2t_term"><span class="id" type="definition">c2t_term</span></a> (<span class="id" type="var">t</span>:term)(c:constant)(x:term) {<span class="id" type="keyword">struct</span> <span class="id" type="var">t</span>} : <a class="idref" href="classcomp.html#classical_completeness.term"><span class="id" type="inductive">term</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.bvar"><span class="id" type="constructor">bvar</span></a> <span class="id" type="var">i</span>    ⇒ (<a class="idref" href="classcomp.html#classical_completeness.bvar"><span class="id" type="constructor">bvar</span></a> <span class="id" type="var">i</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span>    ⇒ <a class="idref" href="classcomp.html#classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.cnst"><span class="id" type="constructor">cnst</span></a> <span class="id" type="var">k</span>   ⇒ <span class="id" type="keyword">if</span> (<a class="idref" href="classcomp.html#classical_completeness.constant_dec"><span class="id" type="lemma">constant_dec</span></a> <span class="id" type="var">k</span> <span class="id" type="var">c</span>) <span class="id" type="keyword">then</span> <span class="id" type="var">x</span> <span class="id" type="keyword">else</span> (<a class="idref" href="classcomp.html#classical_completeness.cnst"><span class="id" type="constructor">cnst</span></a> <span class="id" type="var">k</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="classcomp.html#classical_completeness.func"><span class="id" type="constructor">func</span></a> <span class="id" type="var">f</span> <span class="id" type="var">t1</span> ⇒ <a class="idref" href="classcomp.html#classical_completeness.func"><span class="id" type="constructor">func</span></a> <span class="id" type="var">f</span> (<a class="idref" href="classcomp.html#c2t_term"><span class="id" type="definition">c2t_term</span></a> <span class="id" type="var">t1</span> <span class="id" type="var">c</span> <span class="id" type="var">x</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span> <a name="classical_completeness.c2tl"><span class="id" type="definition">c2tl</span></a> (<span class="id" type="var">l</span>:list <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>)(<span class="id" type="var">c</span>:constant)(v:term) {<span class="id" type="keyword">struct</span> <span class="id" type="var">l</span>} := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">x</span> <span class="id" type="var">x0</span>) ⇒ (<a class="idref" href="classcomp.html#classical_completeness.c2t"><span class="id" type="definition">c2t</span></a> <span class="id" type="var">x</span> <span class="id" type="var">c</span> <span class="id" type="var">v</span>) :: (<a class="idref" href="classcomp.html#c2tl"><span class="id" type="definition">c2tl</span></a> <span class="id" type="var">x0</span> <span class="id" type="var">c</span> <span class="id" type="var">v</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#nil"><span class="id" type="constructor">nil</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#nil"><span class="id" type="constructor">nil</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.c2t_idem"><span class="id" type="lemma">c2t_idem</span></a> : ∀ (<span class="id" type="var">f</span>:formula)(c:constant)(x:term),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.c_appears"><span class="id" type="definition">c_appears</span></a> <span class="id" type="var">f</span> <span class="id" type="var">c</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> → <a class="idref" href="classcomp.html#classical_completeness.c2t"><span class="id" type="definition">c2t</span></a> <span class="id" type="var">f</span> <span class="id" type="var">c</span> <span class="id" type="var">x</span> = <span class="id" type="var">f</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.c2tl_idem"><span class="id" type="lemma">c2tl_idem</span></a> : ∀ (<span class="id" type="var">Gamma</span>:list <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>)(<span class="id" type="var">c</span>:constant)(x:term),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.c_appears_l"><span class="id" type="definition">c_appears_l</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">c</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.c2tl"><span class="id" type="definition">c2tl</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">c</span> <span class="id" type="var">x</span> = <span class="id" type="var">Gamma</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.c2t_lem2"><span class="id" type="lemma">c2t_lem2</span></a> : ∀ (<span class="id" type="var">A</span>:formula)(c:constant)(s:term)(t:term),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.c_appears_term"><span class="id" type="definition">c_appears_term</span></a> <span class="id" type="var">t</span> <span class="id" type="var">c</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> → <a class="idref" href="classcomp.html#classical_completeness.loclt"><span class="id" type="definition">loclt</span></a> <span class="id" type="var">s</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="classcomp.html#classical_completeness.c2t"><span class="id" type="definition">c2t</span></a> <span class="id" type="var">A</span> <span class="id" type="var">c</span> <span class="id" type="var">s</span>) ^^ <span class="id" type="var">t</span> = <a class="idref" href="classcomp.html#classical_completeness.c2t"><span class="id" type="definition">c2t</span></a> (<span class="id" type="var">A</span> ^^ <span class="id" type="var">t</span>) <span class="id" type="var">c</span> <span class="id" type="var">s</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.c2t_lem3"><span class="id" type="lemma">c2t_lem3</span></a> : ∀ (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">A</span> : <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>) (<span class="id" type="var">c</span> : <a class="idref" href="classcomp.html#classical_completeness.constant"><span class="id" type="inductive">constant</span></a>) (<span class="id" type="var">s</span> <span class="id" type="var">t</span> : <a class="idref" href="classcomp.html#classical_completeness.term"><span class="id" type="inductive">term</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.loclt"><span class="id" type="definition">loclt</span></a> <span class="id" type="var">s</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.open_rec"><span class="id" type="definition">open_rec</span></a> <span class="id" type="var">n</span> (<a class="idref" href="classcomp.html#classical_completeness.c2t_term"><span class="id" type="definition">c2t_term</span></a> <span class="id" type="var">t</span> <span class="id" type="var">c</span> <span class="id" type="var">s</span>) (<a class="idref" href="classcomp.html#classical_completeness.c2t"><span class="id" type="definition">c2t</span></a> <span class="id" type="var">A</span> <span class="id" type="var">c</span> <span class="id" type="var">s</span>) = <a class="idref" href="classcomp.html#classical_completeness.c2t"><span class="id" type="definition">c2t</span></a> (<a class="idref" href="classcomp.html#classical_completeness.open_rec"><span class="id" type="definition">open_rec</span></a> <span class="id" type="var">n</span> <span class="id" type="var">t</span> <span class="id" type="var">A</span>) <span class="id" type="var">c</span> <span class="id" type="var">s</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.openrec_lem1"><span class="id" type="lemma">openrec_lem1</span></a> : ∀ <span class="id" type="var">A</span> <span class="id" type="var">n</span> <span class="id" type="var">t</span> <span class="id" type="var">x</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.open_rec"><span class="id" type="definition">open_rec</span></a> <span class="id" type="var">n</span> <span class="id" type="var">t</span> (<a class="idref" href="classcomp.html#classical_completeness.open_rec"><span class="id" type="definition">open_rec</span></a> <span class="id" type="var">n</span> (<a class="idref" href="classcomp.html#classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span>) <span class="id" type="var">A</span>) = <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.open_rec"><span class="id" type="definition">open_rec</span></a> <span class="id" type="var">n</span> (<a class="idref" href="classcomp.html#classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span>) <span class="id" type="var">A</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.locl_all_c2t"><span class="id" type="lemma">locl_all_c2t</span></a> : ∀ <span class="id" type="var">A</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> <span class="id" type="var">A</span> → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∀ <span class="id" type="var">c</span> <span class="id" type="var">x</span>, <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.c2t"><span class="id" type="definition">c2t</span></a> <span class="id" type="var">A</span> <span class="id" type="var">c</span> (<a class="idref" href="classcomp.html#classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span>)).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.thm283"><span class="id" type="lemma">thm283</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">f</span> <span class="id" type="var">x</span> <span class="id" type="var">k</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">f</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> (<a class="idref" href="classcomp.html#classical_completeness.c2tl"><span class="id" type="definition">c2tl</span></a> <span class="id" type="var">Gamma</span> (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> <span class="id" type="var">k</span>) (<a class="idref" href="classcomp.html#classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span>)) (<a class="idref" href="classcomp.html#classical_completeness.c2t"><span class="id" type="definition">c2t</span></a> <span class="id" type="var">f</span> (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> <span class="id" type="var">k</span>) (<a class="idref" href="classcomp.html#classical_completeness.fvar"><span class="id" type="constructor">fvar</span></a> <span class="id" type="var">x</span>)).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.c2t_term_idem"><span class="id" type="lemma">c2t_term_idem</span></a> : ∀ <span class="id" type="var">c</span> <span class="id" type="var">t</span>, <a class="idref" href="classcomp.html#classical_completeness.c2t_term"><span class="id" type="definition">c2t_term</span></a> (<a class="idref" href="classcomp.html#classical_completeness.cnst"><span class="id" type="constructor">cnst</span></a> <span class="id" type="var">c</span>) <span class="id" type="var">c</span> <span class="id" type="var">t</span> = <span class="id" type="var">t</span>.<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#classical_completeness.vanDalen_thm283"><span class="id" type="section">vanDalen_thm283</span></a>.<br/>

<br/>
</div>

<div class="doc">
A section implementing the drinker paradox and another lemma, both
   needed in henkin_equiconsistent. 
</div>
<div class="code">
<span class="id" type="keyword">Section</span> <a name="classical_completeness.drinker"><span class="id" type="section">drinker</span></a>.<br/>

<br/>
</div>

<div class="doc">
some things are more naturally stated in terms of the
     existential quantifier 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Notation</span> "'ex' x" := (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <span class="id" type="var">x</span>))) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 0).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.ex_intro"><span class="id" type="lemma">ex_intro</span></a> : ∀ <span class="id" type="var">Delta</span> <span class="id" type="var">t</span> <span class="id" type="var">f</span>, <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> ((<span class="id" type="var">f</span>^^t)::Delta) (<a class="idref" href="classcomp.html#"'ex'.x""><span class="id" type="notation">ex</span></a> <span class="id" type="var">f</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.ex_elim"><span class="id" type="lemma">ex_elim</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span>, <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">f</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <span class="id" type="var">f</span>))) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(∀ <span class="id" type="var">t</span>, <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> ((<span class="id" type="var">f</span>^^t)::Gamma) <span class="id" type="var">g</span>) → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">g</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.lemma_HE1"><span class="id" type="lemma">lemma_HE1</span></a> : ∀ <span class="id" type="var">Delta</span> <span class="id" type="var">h</span>, <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> (<span class="id" type="var">h</span> ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">h</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Delta</span> ((<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> (<span class="id" type="var">h</span> ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">h</span>))) ⇒ (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <a class="idref" href="classcomp.html#"'ex'.x""><span class="id" type="notation">ex</span></a> (<span class="id" type="var">h</span> ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">h</span>))).<br/>

<br/>
</div>

<div class="doc">
and we also introduce disjunction 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Notation</span> "x ∨ y" := ((<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <span class="id" type="var">x</span>) ⇒ <span class="id" type="var">y</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.disj_intro1"><span class="id" type="lemma">disj_intro1</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span>, <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> (<span class="id" type="var">f</span>::Gamma) (<span class="id" type="var">f</span> ∨ <span class="id" type="var">g</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.disj_intro2"><span class="id" type="lemma">disj_intro2</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span>, <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> (<span class="id" type="var">g</span>::Gamma) (<span class="id" type="var">f</span> ∨ <span class="id" type="var">g</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.disj_elim"><span class="id" type="lemma">disj_elim</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span> <span class="id" type="var">h</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> (<span class="id" type="var">f</span>::Gamma) <span class="id" type="var">h</span> → <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> (<span class="id" type="var">g</span>::Gamma) <span class="id" type="var">h</span> → <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> ((<span class="id" type="var">f</span> ∨ <span class="id" type="var">g</span>) ⇒ <span class="id" type="var">h</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.LEM"><span class="id" type="lemma">LEM</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">f</span>, <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> (<span class="id" type="var">f</span> ∨ <a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <span class="id" type="var">f</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.lemma_HE2_1"><span class="id" type="lemma">lemma_HE2_1</span></a> : ∀ <span class="id" type="var">h</span> <span class="id" type="var">Delta</span>, <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">h</span>) → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">h</span>::Delta) <a class="idref" href="classcomp.html#"'ex'.x""><span class="id" type="notation">ex</span></a> (<span class="id" type="var">h</span> ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">h</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.lemma_HE2_2"><span class="id" type="lemma">lemma_HE2_2</span></a> : ∀ <span class="id" type="var">h</span> <span class="id" type="var">Delta</span>, <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">h</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">h</span> :: <span class="id" type="var">Delta</span>) <a class="idref" href="classcomp.html#"'ex'.x""><span class="id" type="notation">ex</span></a> (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <span class="id" type="var">h</span>).<br/>

<br/>
</div>

<div class="doc">
Drinker paradox 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.lemma_HE2"><span class="id" type="lemma">lemma_HE2</span></a> : ∀ <span class="id" type="var">Delta</span> <span class="id" type="var">h</span>, <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">h</span>) → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Delta</span> (<a class="idref" href="classcomp.html#"'ex'.x""><span class="id" type="notation">ex</span></a> (<span class="id" type="var">h</span> ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">h</span>)).<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#classical_completeness.drinker"><span class="id" type="section">drinker</span></a>.<br/>

<br/>
</div>

<div class="doc">
A predicate for distinguishing Henkin axioms 
</div>
<div class="code">
<span class="id" type="keyword">Definition</span> <a name="classical_completeness.HA"><span class="id" type="definition">HA</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">f</span>:formula ⇒ <br/>
&nbsp;&nbsp;∃ <span class="id" type="var">g</span>:formula, <span class="id" type="var">f</span> = ((<span class="id" type="var">g</span>^^(cnst (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">g</span>)))) ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;∧ <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">g</span>).<br/>

<br/>
</div>

<div class="doc">
We also need a technical lemma for removing duplicate henkin axioms
   from a context 
</div>
<div class="code">
<span class="id" type="keyword">Section</span> <a name="classical_completeness.removing_duplicate_henkin_axioms"><span class="id" type="section">removing_duplicate_henkin_axioms</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.rem_dup_lem1"><span class="id" type="lemma">rem_dup_lem1</span></a> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∀ <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">g</span> <span class="id" type="var">h</span>, <span class="id" type="var">g</span>&lt;&gt;h → <span class="id" type="var">a</span> = ((<span class="id" type="var">g</span> ^^ <a class="idref" href="classcomp.html#classical_completeness.cnst"><span class="id" type="constructor">cnst</span></a> (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">g</span>))) ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">g</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">b</span> = ((<span class="id" type="var">h</span> ^^ <a class="idref" href="classcomp.html#classical_completeness.cnst"><span class="id" type="constructor">cnst</span></a> (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">h</span>))) ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">h</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.depth"><span class="id" type="definition">depth</span></a> <span class="id" type="var">h</span> ≤ <a class="idref" href="classcomp.html#classical_completeness.depth"><span class="id" type="definition">depth</span></a> <span class="id" type="var">g</span> → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.c_appears"><span class="id" type="definition">c_appears</span></a> <span class="id" type="var">b</span> (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">g</span>)) = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
</div>

<div class="doc">
an order of deeper-than for the indexes of the Henkin
     constants of two Henkin axioms; for non-Henkin axioms, no
     behaviour is specified intentionally, but that's not a problem
     because we use this order only for comparing Henkin axioms 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.hgt"><span class="id" type="definition">hgt</span></a> (<span class="id" type="var">a</span> <span class="id" type="var">b</span>:formula) : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">a</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> <span class="id" type="var">_</span> <span class="id" type="var">a'</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">a'</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">a''</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.imp"><span class="id" type="constructor">imp</span></a> <span class="id" type="var">_</span> <span class="id" type="var">b'</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b'</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">b''</span>) ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Arith.Compare_dec.html#leb"><span class="id" type="definition">Compare_dec.leb</span></a> (<a class="idref" href="classcomp.html#classical_completeness.depth"><span class="id" type="definition">depth</span></a> <span class="id" type="var">b''</span>) (<a class="idref" href="classcomp.html#classical_completeness.depth"><span class="id" type="definition">depth</span></a> <span class="id" type="var">a''</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.rem_dup_HA"><span class="id" type="lemma">rem_dup_HA</span></a> : ∀ <span class="id" type="var">Gamma</span>, <a class="idref" href="classcomp.html#classical_completeness.included"><span class="id" type="definition">included</span></a> <span class="id" type="var">Gamma</span> <a class="idref" href="classcomp.html#classical_completeness.HA"><span class="id" type="definition">HA</span></a> → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∃ <span class="id" type="var">Gamma'</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#incl"><span class="id" type="definition">incl</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">Gamma'</span> ∧ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#incl"><span class="id" type="definition">incl</span></a> <span class="id" type="var">Gamma'</span> <span class="id" type="var">Gamma</span> ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀ <span class="id" type="var">a</span> <span class="id" type="var">Delta</span>, <a class="idref" href="lists.html#Suffix"><span class="id" type="inductive">Suffix</span></a> (<span class="id" type="var">a</span>::Delta) <span class="id" type="var">Gamma'</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀ <span class="id" type="var">g</span>, <span class="id" type="var">a</span> = ((<span class="id" type="var">g</span> ^^ <a class="idref" href="classcomp.html#classical_completeness.cnst"><span class="id" type="constructor">cnst</span></a> (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">g</span>))) ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">g</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.c_appears_l"><span class="id" type="definition">c_appears_l</span></a> <span class="id" type="var">Delta</span> (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">g</span>)) = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#classical_completeness.removing_duplicate_henkin_axioms"><span class="id" type="section">removing_duplicate_henkin_axioms</span></a>.<br/>

<br/>
<span class="id" type="keyword">Module</span> <a name="CBAproof_completion"><span class="id" type="module">CBAproof_completion</span></a> := <a class="idref" href="filters.html#"><span class="id" type="module">filter_completion</span></a> <a class="idref" href="classcomp.html#CBAproof"><span class="id" type="module">CBAproof</span></a>.<br/>
<span class="id" type="keyword">Export</span> <span class="id" type="var">CBAproof_completion</span>.<br/>

<br/>
<span class="id" type="keyword">Section</span> <a name="classical_completeness.Completeness"><span class="id" type="section">Completeness</span></a>.<br/>

<br/>
</div>

<div class="doc">
T1 is an extension of T2, both sets of formulas 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.extension"><span class="id" type="definition">extension</span></a> (<span class="id" type="var">T1</span> <span class="id" type="var">T2</span>:formula_set) := ∀ <span class="id" type="var">f</span>, <span class="id" type="var">T2</span> <span class="id" type="var">f</span> → <span class="id" type="var">T1</span> <span class="id" type="var">f</span>.<br/>

<br/>
</div>

<div class="doc">
A classical theory is a set of formulas T closed under
     derivation over a set of Axioms 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.theory"><span class="id" type="definition">theory</span></a> (<span class="id" type="var">Axioms</span>:formula_set)(T:formula_set) := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∀ <span class="id" type="var">f</span>:formula, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">T</span> <span class="id" type="var">f</span> ↔<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∃ <span class="id" type="var">Gamma</span>:list <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="classcomp.html#classical_completeness.included"><span class="id" type="definition">included</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">Axioms</span> ∧ ∃ <span class="id" type="var">p</span>:proof <span class="id" type="var">Gamma</span> <span class="id" type="var">f</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>)).<br/>

<br/>
</div>

<div class="doc">
A set of formulas is Henkin-complete if it contains a Henkin
     axiom for any locally closed formula. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.henkin_complete"><span class="id" type="definition">henkin_complete</span></a> (<span class="id" type="var">T</span>:formula_set) := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∀ <span class="id" type="var">f</span>:formula, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">f</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">T</span> ((<span class="id" type="var">f</span>^^(cnst (<a class="idref" href="classcomp.html#classical_completeness.added"><span class="id" type="constructor">added</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">f</span>)))) ⇒ <a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">f</span>).<br/>

<br/>
</div>

<div class="doc">
Two sets of formulas being equiconsistent 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.equicons"><span class="id" type="definition">equicons</span></a> (<span class="id" type="var">X</span> <span class="id" type="var">Y</span>:formula_set) := <span class="id" type="var">X</span> <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a> ↔ <span class="id" type="var">Y</span> <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a>.<br/>

<br/>
</div>

<div class="doc">
An axiom set is extended with Henkin axioms 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.AxH"><span class="id" type="definition">AxH</span></a> (<span class="id" type="var">T</span> <span class="id" type="var">A</span>:formula_set) := <span class="id" type="keyword">fun</span> <span class="id" type="var">f</span>:formula ⇒ <span class="id" type="var">A</span> <span class="id" type="var">f</span> ∨ <a class="idref" href="classcomp.html#classical_completeness.HA"><span class="id" type="definition">HA</span></a> <span class="id" type="var">f</span>.<br/>

<br/>
</div>

<div class="doc">
A theory that closes the extended axiom set under derivation 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.TH"><span class="id" type="definition">TH</span></a> (<span class="id" type="var">T</span> <span class="id" type="var">A</span>:formula_set) := <span class="id" type="keyword">fun</span> <span class="id" type="var">f</span>:formula ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;∃ <span class="id" type="var">Gamma</span>:list <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.included"><span class="id" type="definition">included</span></a> <span class="id" type="var">Gamma</span> (<a class="idref" href="classcomp.html#classical_completeness.AxH"><span class="id" type="definition">AxH</span></a> <span class="id" type="var">T</span> <span class="id" type="var">A</span>) ∧ ∃ <span class="id" type="var">p</span>:proof <span class="id" type="var">Gamma</span> <span class="id" type="var">f</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>.<br/>

<br/>
</div>

<div class="doc">
When an axiom set contains no added constants 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.noHC"><span class="id" type="definition">noHC</span></a> (<span class="id" type="var">A</span>:formula_set) := ∀ <span class="id" type="var">f</span>, <span class="id" type="var">A</span> <span class="id" type="var">f</span> → <a class="idref" href="classcomp.html#classical_completeness.added_cnsts_f"><span class="id" type="definition">added_cnsts_f</span></a> <span class="id" type="var">f</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Notation</span> "'ex' x" := (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <span class="id" type="var">x</span>))) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 0).<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
If T is a theory over an axiom set which contains no Henkin
     constants, then (TH T) is equiconsistent with T. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.henkin_equiconsistent"><span class="id" type="lemma">henkin_equiconsistent</span></a> : ∀ <span class="id" type="var">A</span> <span class="id" type="var">T</span>:formula_set, <a class="idref" href="classcomp.html#classical_completeness.noHC"><span class="id" type="definition">noHC</span></a> <span class="id" type="var">A</span> → <a class="idref" href="classcomp.html#classical_completeness.theory"><span class="id" type="definition">theory</span></a> <span class="id" type="var">A</span> <span class="id" type="var">T</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="classcomp.html#classical_completeness.TH"><span class="id" type="definition">TH</span></a> <span class="id" type="var">T</span> <span class="id" type="var">A</span>) <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a> → <span class="id" type="var">T</span> <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a>.<br/>

<br/>
</div>

<div class="doc">
If T is a theory whose axiom set has no Henkin constants, then
     (TH T) is a theory which is Henkin-complete and equiconsistent
     with T. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="classical_completeness.enrich"><span class="id" type="lemma">enrich</span></a> : ∀ <span class="id" type="var">T</span> <span class="id" type="var">A</span>:formula_set, <a class="idref" href="classcomp.html#classical_completeness.noHC"><span class="id" type="definition">noHC</span></a> <span class="id" type="var">A</span> → <a class="idref" href="classcomp.html#classical_completeness.theory"><span class="id" type="definition">theory</span></a> <span class="id" type="var">A</span> <span class="id" type="var">T</span> → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.extension"><span class="id" type="definition">extension</span></a> (<a class="idref" href="classcomp.html#classical_completeness.AxH"><span class="id" type="definition">AxH</span></a> <span class="id" type="var">T</span> <span class="id" type="var">A</span>) <span class="id" type="var">A</span> ∧ <a class="idref" href="classcomp.html#classical_completeness.extension"><span class="id" type="definition">extension</span></a> (<a class="idref" href="classcomp.html#classical_completeness.TH"><span class="id" type="definition">TH</span></a> <span class="id" type="var">T</span> <span class="id" type="var">A</span>) <span class="id" type="var">T</span> ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.theory"><span class="id" type="definition">theory</span></a> (<a class="idref" href="classcomp.html#classical_completeness.AxH"><span class="id" type="definition">AxH</span></a> <span class="id" type="var">T</span> <span class="id" type="var">A</span>) (<a class="idref" href="classcomp.html#classical_completeness.TH"><span class="id" type="definition">TH</span></a> <span class="id" type="var">T</span> <span class="id" type="var">A</span>) ∧ <a class="idref" href="classcomp.html#classical_completeness.henkin_complete"><span class="id" type="definition">henkin_complete</span></a> (<a class="idref" href="classcomp.html#classical_completeness.TH"><span class="id" type="definition">TH</span></a> <span class="id" type="var">T</span> <span class="id" type="var">A</span>) ∧ <a class="idref" href="classcomp.html#classical_completeness.equicons"><span class="id" type="definition">equicons</span></a> (<a class="idref" href="classcomp.html#classical_completeness.TH"><span class="id" type="definition">TH</span></a> <span class="id" type="var">T</span> <span class="id" type="var">A</span>) <span class="id" type="var">T</span>.<br/>

<br/>
</div>

<div class="doc">
A theory is also a filter 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="classical_completeness.theory2filter"><span class="id" type="lemma">theory2filter</span></a> : ∀ <span class="id" type="var">T</span> <span class="id" type="var">Ax</span>, <a class="idref" href="classcomp.html#classical_completeness.theory"><span class="id" type="definition">theory</span></a> <span class="id" type="var">Ax</span> <span class="id" type="var">T</span> → <a class="idref" href="classcomp.html#classical_completeness.CBAproof_completion.Filter"><span class="id" type="record">Filter</span></a> <span class="id" type="var">T</span>.<br/>

<br/>
</div>

<div class="doc">
A subsection which implements the model existence lemma by using
     <span class="inlinecode"><span class="id" type="var">enrich</span></span> and the ultrafilter Z from filters.v 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Section</span> <a name="classical_completeness.Completeness.model_existence"><span class="id" type="section">model_existence</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variables</span> (<a name="classical_completeness.Completeness.model_existence.T"><span class="id" type="variable">T</span></a> <a name="classical_completeness.Completeness.model_existence.Ax"><span class="id" type="variable">Ax</span></a>:formula_set)(AxnoHC:noHC <span class="id" type="var">Ax</span>)(<a name="classical_completeness.Completeness.model_existence.Ttheory"><span class="id" type="variable">Ttheory</span></a>:theory <span class="id" type="var">Ax</span> <span class="id" type="var">T</span>).<br/>

<br/>
</div>

<div class="doc">
A Henkin extension of T 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.T1"><span class="id" type="definition">T1</span></a> : <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a> → <span class="id" type="keyword">Prop</span> := <a class="idref" href="classcomp.html#classical_completeness.TH"><span class="id" type="definition">TH</span></a> <span class="id" type="var">T</span> <span class="id" type="var">Ax</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.Ax1"><span class="id" type="definition">Ax1</span></a> : <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a> → <span class="id" type="keyword">Prop</span> := <a class="idref" href="classcomp.html#classical_completeness.AxH"><span class="id" type="definition">AxH</span></a> <span class="id" type="var">T</span> <span class="id" type="var">Ax</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.T1theory"><span class="id" type="definition">T1theory</span></a> := (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#proj1"><span class="id" type="lemma">proj1</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#proj2"><span class="id" type="lemma">proj2</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#proj2"><span class="id" type="lemma">proj2</span></a> (<a class="idref" href="classcomp.html#classical_completeness.enrich"><span class="id" type="lemma">enrich</span></a> <span class="id" type="var">AxnoHC</span> <span class="id" type="var">Ttheory</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.T1filter"><span class="id" type="definition">T1filter</span></a> : <a class="idref" href="classcomp.html#classical_completeness.CBAproof_completion.Filter"><span class="id" type="record">Filter</span></a> <a class="idref" href="classcomp.html#classical_completeness.T1"><span class="id" type="definition">T1</span></a> := <a class="idref" href="classcomp.html#classical_completeness.theory2filter"><span class="id" type="lemma">theory2filter</span></a> <a class="idref" href="classcomp.html#classical_completeness.T1theory"><span class="id" type="definition">T1theory</span></a>.<br/>

<br/>
</div>

<div class="doc">
Extend T1 to a meta-dn filter using the Z defined in filters.v 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> := <a class="idref" href="classcomp.html#classical_completeness.CBAproof_completion.Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="classcomp.html#classical_completeness.T1"><span class="id" type="definition">T1</span></a>.<br/>

<br/>
</div>

<div class="doc">
The properties of Z, proved in thm22 in filters.v 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.lem15"><span class="id" type="definition">lem15</span></a> := <a class="idref" href="classcomp.html#classical_completeness.CBAproof_completion.thm22"><span class="id" type="lemma">thm22</span></a> <a class="idref" href="classcomp.html#classical_completeness.T1filter"><span class="id" type="definition">T1filter</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.model_existence1"><span class="id" type="lemma">model_existence1</span></a> : <a class="idref" href="classcomp.html#classical_completeness.extension"><span class="id" type="definition">extension</span></a> <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> <span class="id" type="var">T</span> ∧ <a class="idref" href="classcomp.html#classical_completeness.equicons"><span class="id" type="definition">equicons</span></a> <span class="id" type="var">T</span> <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a>.<br/>

<br/>
</div>

<div class="doc">
An abbreviation for F_n which lives in formula-&gt;Prop 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.G"><span class="id" type="definition">G</span></a> := <a class="idref" href="classcomp.html#classical_completeness.CBAproof_completion.F_"><span class="id" type="definition">F_</span></a> <a class="idref" href="classcomp.html#classical_completeness.T1"><span class="id" type="definition">T1</span></a>.<br/>

<br/>
</div>

<div class="doc">
The accompanying axioms 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span> <a name="classical_completeness.GAx"><span class="id" type="definition">GAx</span></a> (<span class="id" type="var">n'</span>:nat) : <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n'</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> ⇒ <a class="idref" href="classcomp.html#classical_completeness.Ax1"><span class="id" type="definition">Ax1</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">Fn</span> := <a class="idref" href="classcomp.html#classical_completeness.CBAproof_completion.F_"><span class="id" type="definition">F_</span></a> <a class="idref" href="classcomp.html#classical_completeness.T1"><span class="id" type="definition">T1</span></a> <span class="id" type="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">in</span> <span class="id" type="keyword">fun</span> <span class="id" type="var">f</span>:formula ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#GAx"><span class="id" type="definition">GAx</span></a> <span class="id" type="var">n</span> <span class="id" type="var">f</span> ∨ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.CBAproof.enum"><span class="id" type="definition">enum</span></a> <span class="id" type="var">f</span> = <span class="id" type="var">n</span> ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.CBAproof_completion.equiconsistent"><span class="id" type="definition">equiconsistent</span></a> <span class="id" type="var">Fn</span> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof_completion.up"><span class="id" type="definition">up</span></a> (<a class="idref" href="classcomp.html#classical_completeness.CBAproof_completion.union_singl"><span class="id" type="definition">union_singl</span></a> <span class="id" type="var">Fn</span> <span class="id" type="var">f</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.ZAx"><span class="id" type="definition">ZAx</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">f</span>:formula ⇒ ∃ <span class="id" type="var">n</span>:nat, <a class="idref" href="classcomp.html#classical_completeness.GAx"><span class="id" type="definition">GAx</span></a> <span class="id" type="var">n</span> <span class="id" type="var">f</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.GAx_monotone"><span class="id" type="lemma">GAx_monotone</span></a> : ∀ <span class="id" type="var">n</span> <span class="id" type="var">m</span>:nat, <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Peano.html#le"><span class="id" type="inductive">le</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span> → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀ <span class="id" type="var">f</span>, <a class="idref" href="classcomp.html#classical_completeness.GAx"><span class="id" type="definition">GAx</span></a> <span class="id" type="var">n</span> <span class="id" type="var">f</span> → <a class="idref" href="classcomp.html#classical_completeness.GAx"><span class="id" type="definition">GAx</span></a> <span class="id" type="var">m</span> <span class="id" type="var">f</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.remove_In_neq_In"><span class="id" type="lemma">remove_In_neq_In</span></a> : ∀ <span class="id" type="var">ys</span> <span class="id" type="var">y</span> <span class="id" type="var">xn</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#In"><span class="id" type="definition">In</span></a> <span class="id" type="var">y</span> <span class="id" type="var">ys</span> → <span class="id" type="var">y</span> ≠ <span class="id" type="var">xn</span> → <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#In"><span class="id" type="definition">In</span></a> <span class="id" type="var">y</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#remove"><span class="id" type="definition">remove</span></a> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.id_B_dec"><span class="id" type="lemma">id_B_dec</span></a> <span class="id" type="var">xn</span> <span class="id" type="var">ys</span>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.proof_fold_left"><span class="id" type="lemma">proof_fold_left</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">f</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">f</span> → <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">Gamma</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.top"><span class="id" type="definition">top</span></a> ≤ <span class="id" type="var">f</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.fold_left_proof"><span class="id" type="lemma">fold_left_proof</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">f</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.meet"><span class="id" type="definition">meet</span></a> <span class="id" type="var">Gamma</span> <a class="idref" href="classcomp.html#classical_completeness.CBAproof.top"><span class="id" type="definition">top</span></a> ≤ <span class="id" type="var">f</span> → <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">f</span>.<br/>

<br/>
</div>

<div class="doc">
Every filter F_n is also a theory 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.F_n_theory"><span class="id" type="lemma">F_n_theory</span></a> : ∀ <span class="id" type="var">n</span>, <a class="idref" href="classcomp.html#classical_completeness.theory"><span class="id" type="definition">theory</span></a> (<a class="idref" href="classcomp.html#classical_completeness.GAx"><span class="id" type="definition">GAx</span></a> <span class="id" type="var">n</span>) (<a class="idref" href="classcomp.html#classical_completeness.G"><span class="id" type="definition">G</span></a> <span class="id" type="var">n</span>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="classical_completeness.Z'theory"><span class="id" type="lemma">Z'theory</span></a> : <a class="idref" href="classcomp.html#classical_completeness.theory"><span class="id" type="definition">theory</span></a> <a class="idref" href="classcomp.html#classical_completeness.ZAx"><span class="id" type="definition">ZAx</span></a> <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.metaDN"><span class="id" type="definition">metaDN</span></a> (<span class="id" type="var">X</span>:formula_set) := ∀ <span class="id" type="var">f</span>:formula,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">X</span> (<a class="idref" href="classcomp.html#"'neg'.A""><span class="id" type="notation">neg</span></a> <span class="id" type="var">f</span>) → <span class="id" type="var">X</span> <a class="idref" href="classcomp.html#classical_completeness.bot"><span class="id" type="constructor">bot</span></a>) → <span class="id" type="var">X</span> <span class="id" type="var">f</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.metaDNZ'"><span class="id" type="lemma">metaDNZ'</span></a>: <a class="idref" href="classcomp.html#classical_completeness.metaDN"><span class="id" type="definition">metaDN</span></a> <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.model_existence2"><span class="id" type="lemma">model_existence2</span></a> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ <span class="id" type="var">A</span> <span class="id" type="var">B</span> : <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>, <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> (<span class="id" type="var">A</span> ⇒ <span class="id" type="var">B</span>) → <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> <span class="id" type="var">A</span> → <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> <span class="id" type="var">B</span>) ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ <span class="id" type="var">A</span> <span class="id" type="var">B</span> : <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>, (<a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> <span class="id" type="var">A</span> → <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> <span class="id" type="var">B</span>) → <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> (<span class="id" type="var">A</span> ⇒ <span class="id" type="var">B</span>)).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.model_existence3'"><span class="id" type="lemma">model_existence3'</span></a> : <a class="idref" href="classcomp.html#classical_completeness.henkin_complete"><span class="id" type="definition">henkin_complete</span></a> <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.model_existence3"><span class="id" type="lemma">model_existence3</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ <span class="id" type="var">A</span>, <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>) → (∀ <span class="id" type="var">t</span>:term, <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> (<span class="id" type="var">A</span>^^t))) ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ <span class="id" type="var">A</span>, <a class="idref" href="classcomp.html#classical_completeness.locl"><span class="id" type="definition">locl</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>) → (∀ <span class="id" type="var">t</span>:term, <a class="idref" href="classcomp.html#classical_completeness.loclt"><span class="id" type="definition">loclt</span></a> <span class="id" type="var">t</span> → <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> (<span class="id" type="var">A</span>^^t)) → <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> (<a class="idref" href="classcomp.html#classical_completeness.all"><span class="id" type="constructor">all</span></a> <span class="id" type="var">A</span>)).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="classical_completeness.model_existence"><span class="id" type="lemma">model_existence</span></a> : <a class="idref" href="classcomp.html#classical_completeness.extension"><span class="id" type="definition">extension</span></a> <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> <span class="id" type="var">T</span> ∧ <a class="idref" href="classcomp.html#classical_completeness.model"><span class="id" type="record">model</span></a> <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a> ∧ <a class="idref" href="classcomp.html#classical_completeness.equicons"><span class="id" type="definition">equicons</span></a> <span class="id" type="var">T</span> <a class="idref" href="classcomp.html#classical_completeness.Z'"><span class="id" type="definition">Z'</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#classical_completeness.Completeness.model_existence"><span class="id" type="section">model_existence</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span> <a name="classical_completeness.HCl"><span class="id" type="definition">HCl</span></a> (<span class="id" type="var">A</span>:list <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" type="inductive">bool</span></a> := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">A</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#nil"><span class="id" type="constructor">nil</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">f</span> <span class="id" type="var">fs</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#orb"><span class="id" type="definition">orb</span></a> (<a class="idref" href="classcomp.html#classical_completeness.added_cnsts_f"><span class="id" type="definition">added_cnsts_f</span></a> <span class="id" type="var">f</span>) (<a class="idref" href="classcomp.html#HCl"><span class="id" type="definition">HCl</span></a> <span class="id" type="var">fs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="classical_completeness.HCl_correct"><span class="id" type="lemma">HCl_correct</span></a> : ∀ <span class="id" type="var">f</span> <span class="id" type="var">Gamma</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#In"><span class="id" type="definition">In</span></a> <span class="id" type="var">f</span> <span class="id" type="var">Gamma</span> → <a class="idref" href="classcomp.html#classical_completeness.HCl"><span class="id" type="definition">HCl</span></a> <span class="id" type="var">Gamma</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.added_cnsts_f"><span class="id" type="definition">added_cnsts_f</span></a> <span class="id" type="var">f</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.noHCf"><span class="id" type="definition">noHCf</span></a> (<span class="id" type="var">f</span>:formula) := <a class="idref" href="classcomp.html#classical_completeness.added_cnsts_f"><span class="id" type="definition">added_cnsts_f</span></a> <span class="id" type="var">f</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="classical_completeness.noHCl"><span class="id" type="definition">noHCl</span></a> (<span class="id" type="var">A</span>:list <a class="idref" href="classcomp.html#classical_completeness.formula"><span class="id" type="inductive">formula</span></a>) := <a class="idref" href="classcomp.html#classical_completeness.HCl"><span class="id" type="definition">HCl</span></a> <span class="id" type="var">A</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
</div>

<div class="doc">
Finally, the completeness theorem. If Gamma and A contain no Henkin constants, that is, if they are built up of/like usual formulas, and if A is true in every model in which Gamma is true, then there is a derivation of A with hypothesis form Gamma. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="classical_completeness.completeness"><span class="id" type="lemma">completeness</span></a> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span>, <a class="idref" href="classcomp.html#classical_completeness.noHCl"><span class="id" type="definition">noHCl</span></a> <span class="id" type="var">Gamma</span> → <a class="idref" href="classcomp.html#classical_completeness.noHCf"><span class="id" type="definition">noHCf</span></a> <span class="id" type="var">A</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="classcomp.html#classical_completeness.valid"><span class="id" type="definition">valid</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span> → <a class="idref" href="classcomp.html#classical_completeness.proof"><span class="id" type="inductive">proof</span></a> <span class="id" type="var">Gamma</span> <span class="id" type="var">A</span>.<br/>
 
<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#classical_completeness.Completeness"><span class="id" type="section">Completeness</span></a>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="classcomp.html#classical_completeness"><span class="id" type="module">classical_completeness</span></a>.<br/>
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>