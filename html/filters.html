<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>filters</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library filters</h1>

<div class="code">
</div>

<div class="doc">
A proof that every filter F over a countable boolean algebra can
   be extended to a complete filter equiconsistent with
   F. (Ultrafilter Theorem)

<br/> <br/>
   This file is used by the completeness theorem from classcomp.v, but
   it can be used in other contexts, it is a standalone module.
 
</div>
<div class="code">
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.setoid_ring.Ring.html#"><span class="id" type="library">Ring</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#"><span class="id" type="library">List</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Arith.Compare_dec.html#"><span class="id" type="library">Compare_dec</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Setoids.Setoid.html#"><span class="id" type="library">Setoid</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Classes.Morphisms.html#"><span class="id" type="library">Morphisms</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Definition of Countable Boolean Algebra (over a setoid) 
</div>
<div class="code">
<span class="id" type="keyword">Module</span> <span class="id" type="keyword">Type</span> <a name="CBA"><span class="id" type="module">CBA</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <span class="id" type="keyword">Inline</span> <a name="CBA.B"><span class="id" type="axiom">B</span></a>:Set.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span><span class="id" type="var">s</span> (<a name="CBA.meet"><span class="id" type="axiom">meet</span></a> <a name="CBA.join"><span class="id" type="axiom">join</span></a>:B → <a class="idref" href="filters.html#CBA.B"><span class="id" type="axiom">B</span></a> → <a class="idref" href="filters.html#CBA.B"><span class="id" type="axiom">B</span></a>)(<a name="CBA.bott"><span class="id" type="axiom">bott</span></a> <a name="CBA.top"><span class="id" type="axiom">top</span></a>:B)(compl:B → <a class="idref" href="filters.html#CBA.B"><span class="id" type="axiom">B</span></a>).<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <a name="CBA.eq_B"><span class="id" type="axiom">eq_B</span></a> : <a class="idref" href="filters.html#CBA.B"><span class="id" type="axiom">B</span></a>  →  <a class="idref" href="filters.html#CBA.B"><span class="id" type="axiom">B</span></a>  →  <span class="id" type="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Notation</span> "x == y" := (<a class="idref" href="filters.html#CBA.eq_B"><span class="id" type="axiom">eq_B</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 70, <span class="id" type="var">no</span> <span class="id" type="var">associativity</span>).<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.eq_B_refl"><span class="id" type="axiom">eq_B_refl</span></a>  : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Relations.Relation_Definitions.html#reflexive"><span class="id" type="definition">reflexive</span></a> <a class="idref" href="filters.html#CBA.B"><span class="id" type="axiom">B</span></a> <a class="idref" href="filters.html#CBA.eq_B"><span class="id" type="axiom">eq_B</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.eq_B_symm"><span class="id" type="axiom">eq_B_symm</span></a>  : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Relations.Relation_Definitions.html#symmetric"><span class="id" type="definition">symmetric</span></a> <a class="idref" href="filters.html#CBA.B"><span class="id" type="axiom">B</span></a> <a class="idref" href="filters.html#CBA.eq_B"><span class="id" type="axiom">eq_B</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.eq_B_trans"><span class="id" type="axiom">eq_B_trans</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Relations.Relation_Definitions.html#transitive"><span class="id" type="definition">transitive</span></a> <a class="idref" href="filters.html#CBA.B"><span class="id" type="axiom">B</span></a> <a class="idref" href="filters.html#CBA.eq_B"><span class="id" type="axiom">eq_B</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.eq_B_meet_morph"><span class="id" type="axiom">eq_B_meet_morph</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Classes.Morphisms.html#Morphism"><span class="id" type="class">Morphism</span></a> (<a class="idref" href="filters.html#CBA.eq_B"><span class="id" type="axiom">eq_B</span></a> ⇒ <a class="idref" href="filters.html#CBA.eq_B"><span class="id" type="axiom">eq_B</span></a> ⇒ <a class="idref" href="filters.html#CBA.eq_B"><span class="id" type="axiom">eq_B</span></a>) <a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.eq_B_join_morph"><span class="id" type="axiom">eq_B_join_morph</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Classes.Morphisms.html#Morphism"><span class="id" type="class">Morphism</span></a> (<a class="idref" href="filters.html#CBA.eq_B"><span class="id" type="axiom">eq_B</span></a> ⇒ <a class="idref" href="filters.html#CBA.eq_B"><span class="id" type="axiom">eq_B</span></a> ⇒ <a class="idref" href="filters.html#CBA.eq_B"><span class="id" type="axiom">eq_B</span></a>) <a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.enum"><span class="id" type="axiom">enum</span></a> : <a class="idref" href="filters.html#CBA.B"><span class="id" type="axiom">B</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.countable"><span class="id" type="axiom">countable</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <a class="idref" href="filters.html#CBA.enum"><span class="id" type="axiom">enum</span></a> <span class="id" type="var">x</span> = <a class="idref" href="filters.html#CBA.enum"><span class="id" type="axiom">enum</span></a> <span class="id" type="var">y</span> → <span class="id" type="var">x</span> = <span class="id" type="var">y</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.meet_idem"><span class="id" type="axiom">meet_idem</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">x</span> == <span class="id" type="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.join_idem"><span class="id" type="axiom">join_idem</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">x</span> == <span class="id" type="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.meet_comm"><span class="id" type="axiom">meet_comm</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> == <a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">y</span> <span class="id" type="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.join_comm"><span class="id" type="axiom">join_comm</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> == <a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">y</span> <span class="id" type="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.meet_assoc"><span class="id" type="axiom">meet_assoc</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>, <a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">x</span> (<a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">y</span> <span class="id" type="var">z</span>) == <a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> (<a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) <span class="id" type="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.join_assoc"><span class="id" type="axiom">join_assoc</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>, <a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">x</span> (<a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">y</span> <span class="id" type="var">z</span>) == <a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> (<a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) <span class="id" type="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.meet_absorb"><span class="id" type="axiom">meet_absorb</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">x</span> (<a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) == <span class="id" type="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.join_absorb"><span class="id" type="axiom">join_absorb</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">x</span> (<a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) == <span class="id" type="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.meet_distrib"><span class="id" type="axiom">meet_distrib</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> (<a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) <span class="id" type="var">z</span> == <a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> (<a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">z</span>) (<a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">y</span> <span class="id" type="var">z</span>).<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.join_distrib"><span class="id" type="axiom">join_distrib</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> (<a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) <span class="id" type="var">z</span> == <a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> (<a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">z</span>) (<a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">y</span> <span class="id" type="var">z</span>).<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.meet_bott"><span class="id" type="axiom">meet_bott</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <a class="idref" href="filters.html#CBA.bott"><span class="id" type="axiom">bott</span></a> <span class="id" type="var">x</span> == <a class="idref" href="filters.html#CBA.bott"><span class="id" type="axiom">bott</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.join_bott"><span class="id" type="axiom">join_bott</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <a class="idref" href="filters.html#CBA.bott"><span class="id" type="axiom">bott</span></a> <span class="id" type="var">x</span> == <span class="id" type="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.meet_top"><span class="id" type="axiom">meet_top</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <a class="idref" href="filters.html#CBA.top"><span class="id" type="axiom">top</span></a> <span class="id" type="var">x</span> == <span class="id" type="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.join_top"><span class="id" type="axiom">join_top</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <a class="idref" href="filters.html#CBA.top"><span class="id" type="axiom">top</span></a> <span class="id" type="var">x</span> == <a class="idref" href="filters.html#CBA.top"><span class="id" type="axiom">top</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.meet_compl"><span class="id" type="axiom">meet_compl</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="filters.html#CBA.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">x</span> (<a class="idref" href="filters.html#CBA.compl"><span class="id" type="axiom">compl</span></a> <span class="id" type="var">x</span>) == <a class="idref" href="filters.html#CBA.bott"><span class="id" type="axiom">bott</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.join_compl"><span class="id" type="axiom">join_compl</span></a> : ∀ <span class="id" type="var">x</span>, <a class="idref" href="filters.html#CBA.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">x</span> (<a class="idref" href="filters.html#CBA.compl"><span class="id" type="axiom">compl</span></a> <span class="id" type="var">x</span>) == <a class="idref" href="filters.html#CBA.top"><span class="id" type="axiom">top</span></a>.<br/>

<br/>
</div>

<div class="doc">
We also need that identity <span class="inlinecode"><span class="id" type="var">id_B</span></span> is decidable in 1 place. Note that this is not that <span class="inlinecode"><span class="id" type="var">id_B</span></span> is definitional equality, it has nothing to do with the equality of the setoid. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.id_B_dec"><span class="id" type="axiom">id_B_dec</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="filters.html#CBA.B"><span class="id" type="axiom">B</span></a>, {<span class="id" type="var">x</span> = <span class="id" type="var">y</span>}+{x ≠ <span class="id" type="var">y</span>}.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.id_B_dec_right"><span class="id" type="axiom">id_B_dec_right</span></a> : ∀ (<span class="id" type="var">x</span> <span class="id" type="var">y</span>:B), <span class="id" type="var">x</span>&lt;&gt;y →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;∃ <span class="id" type="var">H</span>:x&lt;&gt;y, <a class="idref" href="filters.html#CBA.id_B_dec"><span class="id" type="axiom">id_B_dec</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Specif.html#right"><span class="id" type="constructor">right</span></a> (<span class="id" type="var">x</span>=y) <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Axiom</span> <a name="CBA.id_B_dec_left"><span class="id" type="axiom">id_B_dec_left</span></a> : ∀ <span class="id" type="var">x</span>:B, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∃ <span class="id" type="var">H</span>:x=x, <a class="idref" href="filters.html#CBA.id_B_dec"><span class="id" type="axiom">id_B_dec</span></a> <span class="id" type="var">x</span> <span class="id" type="var">x</span> = <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Specif.html#left"><span class="id" type="constructor">left</span></a> (<span class="id" type="var">x</span>&lt;&gt;x) <span class="id" type="var">H</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="filters.html#CBA"><span class="id" type="module">CBA</span></a>.<br/>

<br/>
<span class="id" type="keyword">Module</span> <a name="filter_completion"><span class="id" type="module">filter_completion</span></a> (<span class="id" type="var">cba</span> : <a class="idref" href="filters.html#CBA"><span class="id" type="module">CBA</span></a>).<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Export</span> <span class="id" type="var">cba</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Add</span> <span class="id" type="var">Relation</span> <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a> <a class="idref" href="filters.html#cba.eq_B"><span class="id" type="axiom">eq_B</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span> <span class="id" type="var">proved</span> <span class="id" type="tactic">by</span> <a class="idref" href="filters.html#cba.eq_B_refl"><span class="id" type="axiom">eq_B_refl</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">symmetry</span> <span class="id" type="var">proved</span> <span class="id" type="tactic">by</span> <a class="idref" href="filters.html#cba.eq_B_symm"><span class="id" type="axiom">eq_B_symm</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">transitivity</span> <span class="id" type="var">proved</span> <span class="id" type="tactic">by</span> <a class="idref" href="filters.html#cba.eq_B_trans"><span class="id" type="axiom">eq_B_trans</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">as</span> <span class="id" type="var">eq_B_relation</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Add</span> <span class="id" type="var">Morphism</span> <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">signature</span> <a class="idref" href="filters.html#cba.eq_B"><span class="id" type="axiom">eq_B</span></a> ⇒ <a class="idref" href="filters.html#cba.eq_B"><span class="id" type="axiom">eq_B</span></a> ⇒ <a class="idref" href="filters.html#cba.eq_B"><span class="id" type="axiom">eq_B</span></a> <span class="id" type="keyword">as</span> <span class="id" type="var">meet_morphism</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Add</span> <span class="id" type="var">Morphism</span> <a class="idref" href="filters.html#cba.join"><span class="id" type="axiom">join</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">signature</span> <a class="idref" href="filters.html#cba.eq_B"><span class="id" type="axiom">eq_B</span></a> ⇒ <a class="idref" href="filters.html#cba.eq_B"><span class="id" type="axiom">eq_B</span></a> ⇒ <a class="idref" href="filters.html#cba.eq_B"><span class="id" type="axiom">eq_B</span></a> <span class="id" type="keyword">as</span> <span class="id" type="var">join_morphism</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A boolean algebra is also a semi-ring, useful because Coq can automatically solve equations for in such cases. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="filter_completion.CBA_semiring"><span class="id" type="lemma">CBA_semiring</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.setoid_ring.Ring_theory.html#semi_ring_theory"><span class="id" type="record">semi_ring_theory</span></a> <a class="idref" href="filters.html#cba.bott"><span class="id" type="axiom">bott</span></a> <a class="idref" href="filters.html#cba.top"><span class="id" type="axiom">top</span></a> <a class="idref" href="filters.html#cba.join"><span class="id" type="axiom">join</span></a> <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <a class="idref" href="filters.html#cba.eq_B"><span class="id" type="axiom">eq_B</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Add</span> <span class="id" type="var">Ring</span> <span class="id" type="var">B_semiring</span> : <a class="idref" href="filters.html#filter_completion.CBA_semiring"><span class="id" type="lemma">CBA_semiring</span></a>.<br/>

<br/>
</div>

<div class="doc">
Lattice as an algebra is equivalent to a lattice as a poset, so
      we can define an ordering. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="filter_completion.leq"><span class="id" type="definition">leq</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> ⇒ <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> == <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.leq'"><span class="id" type="lemma">leq'</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <a class="idref" href="filters.html#filter_completion.leq"><span class="id" type="definition">leq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> ↔ <a class="idref" href="filters.html#cba.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> == <span class="id" type="var">y</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Delimit</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">B_scope</span> <span class="id" type="keyword">with</span> <span class="id" type="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">B_scope</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Notation</span> "x &amp;&amp; y" := (<a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 40, <span class="id" type="var">left</span> <span class="id" type="var">associativity</span>) : <span class="id" type="var">B_scope</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Notation</span> "- x" := (<a class="idref" href="filters.html#cba.compl"><span class="id" type="axiom">compl</span></a> <span class="id" type="var">x</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 35, <span class="id" type="var">right</span> <span class="id" type="var">associativity</span>) : <span class="id" type="var">B_scope</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Notation</span> "x || y" := (<a class="idref" href="filters.html#cba.join"><span class="id" type="axiom">join</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 50, <span class="id" type="var">left</span> <span class="id" type="var">associativity</span>) : <span class="id" type="var">B_scope</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Notation</span> "x ≤ y" := (<a class="idref" href="filters.html#filter_completion.leq"><span class="id" type="definition">leq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) : <span class="id" type="var">B_scope</span>.<br/>

<br/>
</div>

<div class="doc">
When a subset F of B is a filter 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Record</span> <a name="filter_completion.Filter"><span class="id" type="record">Filter</span></a> (<span class="id" type="var">F</span>:B → <span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> := {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="filter_completion.nonempty"><span class="id" type="projection">nonempty</span></a> : ∃ <span class="id" type="var">x</span>:B, <span class="id" type="var">F</span> <span class="id" type="var">x</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="filter_completion.upwards_closed"><span class="id" type="projection">upwards_closed</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>:B, <span class="id" type="var">F</span> <span class="id" type="var">x</span> → <a class="idref" href="filters.html#filter_completion.leq"><span class="id" type="definition">leq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> → <span class="id" type="var">F</span> <span class="id" type="var">y</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="filter_completion.meet_closed"><span class="id" type="projection">meet_closed</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>:B, <span class="id" type="var">F</span> <span class="id" type="var">x</span> → <span class="id" type="var">F</span> <span class="id" type="var">y</span> → <span class="id" type="var">F</span> (<a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)<br/>
&nbsp;&nbsp;}.<br/>

<br/>
</div>

<div class="doc">
The closure of the subset X, <span class="inlinecode"><span class="id" type="var">up</span> <span class="id" type="var">X</span></span>, is the least filter containing X.

<br/> <br/>
     Conjuction of finite (but arbitrary) lenght is represented by the
     List operation fold_left. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="filter_completion.up"><span class="id" type="definition">up</span></a> (<span class="id" type="var">X</span>:B → <span class="id" type="keyword">Prop</span>) := <span class="id" type="keyword">fun</span> <span class="id" type="var">z</span>:B ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;∃ <span class="id" type="var">n</span>:nat, ∃ <span class="id" type="var">ys</span>:list <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#length"><span class="id" type="definition">length</span></a> <span class="id" type="var">ys</span> = <span class="id" type="var">n</span> ∧ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a</span>:Prop)(b:B) ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#and"><span class="id" type="inductive">and</span></a> <span class="id" type="var">a</span> (<span class="id" type="var">X</span> <span class="id" type="var">b</span>)) <span class="id" type="var">ys</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="filters.html#filter_completion.leq"><span class="id" type="definition">leq</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">ys</span> <a class="idref" href="filters.html#cba.top"><span class="id" type="axiom">top</span></a>) <span class="id" type="var">z</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="filter_completion.union_singl"><span class="id" type="definition">union_singl</span></a> (<span class="id" type="var">F</span>:B → <span class="id" type="keyword">Prop</span>)(<span class="id" type="var">x</span>:B) := <span class="id" type="keyword">fun</span> <span class="id" type="var">b</span>:B ⇒ <span class="id" type="var">F</span> <span class="id" type="var">b</span> ∨ <span class="id" type="var">b</span>=x.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="filter_completion.inconsistent"><span class="id" type="definition">inconsistent</span></a> (<span class="id" type="var">F</span>:B → <span class="id" type="keyword">Prop</span>) := <span class="id" type="var">F</span> <a class="idref" href="filters.html#cba.bott"><span class="id" type="axiom">bott</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="filter_completion.equiconsistent"><span class="id" type="definition">equiconsistent</span></a> (<span class="id" type="var">F</span> <span class="id" type="var">G</span>:B → <span class="id" type="keyword">Prop</span>) := <a class="idref" href="filters.html#filter_completion.inconsistent"><span class="id" type="definition">inconsistent</span></a> <span class="id" type="var">F</span> ↔ <a class="idref" href="filters.html#filter_completion.inconsistent"><span class="id" type="definition">inconsistent</span></a> <span class="id" type="var">G</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="filter_completion.element_complete"><span class="id" type="definition">element_complete</span></a> (<span class="id" type="var">F</span>:B → <span class="id" type="keyword">Prop</span>)(<span class="id" type="var">x</span>:B) := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="filters.html#filter_completion.equiconsistent"><span class="id" type="definition">equiconsistent</span></a> <span class="id" type="var">F</span> (<a class="idref" href="filters.html#filter_completion.up"><span class="id" type="definition">up</span></a> (<a class="idref" href="filters.html#filter_completion.union_singl"><span class="id" type="definition">union_singl</span></a> <span class="id" type="var">F</span> <span class="id" type="var">x</span>)) → <span class="id" type="var">F</span> <span class="id" type="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
This notion of completeness of a filter is the key to having a constructive proof. This notion is constructivelly weaker than, but classically equivalent to, the more usual notion: either x in F, or ~x in F. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="filter_completion.complete"><span class="id" type="definition">complete</span></a> (<span class="id" type="var">F</span>:B → <span class="id" type="keyword">Prop</span>) := ∀ <span class="id" type="var">x</span>:B, <a class="idref" href="filters.html#filter_completion.element_complete"><span class="id" type="definition">element_complete</span></a> <span class="id" type="var">F</span> <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.leq_refl"><span class="id" type="lemma">leq_refl</span></a> : ∀ <span class="id" type="var">x</span>:B, <span class="id" type="var">x</span> ≤ <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.leq_trans"><span class="id" type="lemma">leq_trans</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>:B, <a class="idref" href="filters.html#filter_completion.leq"><span class="id" type="definition">leq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> → <a class="idref" href="filters.html#filter_completion.leq"><span class="id" type="definition">leq</span></a> <span class="id" type="var">y</span> <span class="id" type="var">z</span> → <a class="idref" href="filters.html#filter_completion.leq"><span class="id" type="definition">leq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">z</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.eq_B_leq"><span class="id" type="lemma">eq_B_leq</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span>:B, <span class="id" type="var">x</span>==y → <span class="id" type="var">x</span> ≤ <span class="id" type="var">y</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Add</span> <span class="id" type="var">Morphism</span> <a class="idref" href="filters.html#filter_completion.leq"><span class="id" type="definition">leq</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">signature</span> <a class="idref" href="filters.html#cba.eq_B"><span class="id" type="axiom">eq_B</span></a> ⇒ <a class="idref" href="filters.html#cba.eq_B"><span class="id" type="axiom">eq_B</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#iff"><span class="id" type="definition">iff</span></a> <span class="id" type="keyword">as</span> <span class="id" type="var">leq_morphism</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.meet_leq_compat"><span class="id" type="lemma">meet_leq_compat</span></a> : ∀ <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span>, <span class="id" type="var">a</span> ≤ <span class="id" type="var">b</span> → <span class="id" type="var">c</span> ≤ <span class="id" type="var">d</span> → <span class="id" type="var">a</span> &amp;&amp; <span class="id" type="var">c</span>  ≤  <span class="id" type="var">b</span> &amp;&amp; <span class="id" type="var">d</span>.<br/>

<br/>
</div>

<div class="doc">
The next few lemmas with names "fold_left*" and "lemma*" are used to handle the representation of a finite number of conjunctions by a list. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.fold_left_meet_morphism"><span class="id" type="lemma">fold_left_meet_morphism</span></a> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">bs</span>, <span class="id" type="var">x</span>==y → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">bs</span> <span class="id" type="var">x</span> == <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">bs</span> <span class="id" type="var">y</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.fold_left_meet_cons"><span class="id" type="lemma">fold_left_meet_cons</span></a> : ∀ <span class="id" type="var">bs</span> <span class="id" type="var">b</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">b</span> <span class="id" type="var">bs</span>) <a class="idref" href="filters.html#cba.top"><span class="id" type="axiom">top</span></a> == <span class="id" type="var">b</span> &amp;&amp; (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">bs</span> <a class="idref" href="filters.html#cba.top"><span class="id" type="axiom">top</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.fold_left_impl"><span class="id" type="lemma">fold_left_impl</span></a> : ∀ (<span class="id" type="var">X</span>:B → <span class="id" type="keyword">Prop</span>)(<span class="id" type="var">xs</span>:list <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>)(<span class="id" type="var">Q</span> <span class="id" type="var">P</span>:Prop), (<span class="id" type="var">Q</span> → <span class="id" type="var">P</span>) → <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a</span> : <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">b</span> : <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>) ⇒ <span class="id" type="var">a</span> ∧ <span class="id" type="var">X</span> <span class="id" type="var">b</span>) <span class="id" type="var">xs</span> <span class="id" type="var">Q</span> → <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a</span> : <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">b</span> : <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>) ⇒ <span class="id" type="var">a</span> ∧ <span class="id" type="var">X</span> <span class="id" type="var">b</span>) <span class="id" type="var">xs</span> <span class="id" type="var">P</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.fold_left_app_lem"><span class="id" type="lemma">fold_left_app_lem</span></a> : ∀ <span class="id" type="var">xs</span> <span class="id" type="var">ys</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> (<span class="id" type="var">xs</span> ++ <span class="id" type="var">ys</span>) <a class="idref" href="filters.html#cba.top"><span class="id" type="axiom">top</span></a> == <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">xs</span> <a class="idref" href="filters.html#cba.top"><span class="id" type="axiom">top</span></a> &amp;&amp; <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">ys</span> <a class="idref" href="filters.html#cba.top"><span class="id" type="axiom">top</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.up_filter"><span class="id" type="lemma">up_filter</span></a> : ∀ <span class="id" type="var">X</span>:B → <span class="id" type="keyword">Prop</span>, <a class="idref" href="filters.html#filter_completion.Filter"><span class="id" type="record">Filter</span></a> (<a class="idref" href="filters.html#filter_completion.up"><span class="id" type="definition">up</span></a> <span class="id" type="var">X</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.filter_top"><span class="id" type="lemma">filter_top</span></a> : ∀ <span class="id" type="var">F</span>:B → <span class="id" type="keyword">Prop</span>, <a class="idref" href="filters.html#filter_completion.Filter"><span class="id" type="record">Filter</span></a> <span class="id" type="var">F</span> → <span class="id" type="var">F</span> <a class="idref" href="filters.html#cba.top"><span class="id" type="axiom">top</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.lemma3"><span class="id" type="lemma">lemma3</span></a> : ∀ (<span class="id" type="var">T</span>:Type)(Hdec:forall <span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">T</span>, {<span class="id" type="var">x</span> = <span class="id" type="var">y</span>} + {<span class="id" type="var">x</span> ≠ <span class="id" type="var">y</span>})(<span class="id" type="var">x</span>:T)(ys:list <span class="id" type="var">T</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#incl"><span class="id" type="definition">incl</span></a> <span class="id" type="var">ys</span> (<span class="id" type="var">x</span> :: <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#remove"><span class="id" type="definition">remove</span></a> <span class="id" type="var">Hdec</span> <span class="id" type="var">x</span> <span class="id" type="var">ys</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.lemma2"><span class="id" type="lemma">lemma2</span></a> : ∀ <span class="id" type="var">A</span> <span class="id" type="var">C</span>:list <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#incl"><span class="id" type="definition">incl</span></a> <span class="id" type="var">A</span> <span class="id" type="var">C</span> → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="filters.html#filter_completion.leq"><span class="id" type="definition">leq</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">C</span> <a class="idref" href="filters.html#cba.top"><span class="id" type="axiom">top</span></a>) (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">A</span> <a class="idref" href="filters.html#cba.top"><span class="id" type="axiom">top</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.filter_memb_morph"><span class="id" type="lemma">filter_memb_morph</span></a> : ∀ <span class="id" type="var">F</span>, <a class="idref" href="filters.html#filter_completion.Filter"><span class="id" type="record">Filter</span></a> <span class="id" type="var">F</span> → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;∀ (<span class="id" type="var">x</span> <span class="id" type="var">y</span>:B), <span class="id" type="var">x</span>==y → <span class="id" type="var">F</span> <span class="id" type="var">x</span> → <span class="id" type="var">F</span> <span class="id" type="var">y</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.lemma4"><span class="id" type="lemma">lemma4</span></a> : ∀ <span class="id" type="var">xs</span> <span class="id" type="var">F</span>, <a class="idref" href="filters.html#filter_completion.Filter"><span class="id" type="record">Filter</span></a> <span class="id" type="var">F</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">b</span> : <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>) ⇒ <span class="id" type="var">A</span> ∧ <span class="id" type="var">F</span> <span class="id" type="var">b</span>) <span class="id" type="var">xs</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">F</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> <a class="idref" href="filters.html#cba.meet"><span class="id" type="axiom">meet</span></a> <span class="id" type="var">xs</span> <a class="idref" href="filters.html#cba.top"><span class="id" type="axiom">top</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.lemma61"><span class="id" type="lemma">lemma61</span></a> : ∀ (<span class="id" type="var">f</span>:B → <span class="id" type="keyword">Prop</span>)(<span class="id" type="var">l</span>:list <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>)(<span class="id" type="var">basecase</span>:Prop)(P:Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">R</span>:Prop)(x:B) ⇒ <span class="id" type="var">R</span> ∧ (<span class="id" type="var">f</span> <span class="id" type="var">x</span>)) <span class="id" type="var">l</span> (<span class="id" type="var">basecase</span> ∧ <span class="id" type="var">P</span>) → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">R</span>:Prop)(x:B) ⇒ <span class="id" type="var">R</span> ∧ (<span class="id" type="var">f</span> <span class="id" type="var">x</span>)) <span class="id" type="var">l</span> <span class="id" type="var">basecase</span>) ∧ <span class="id" type="var">P</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.lemma62"><span class="id" type="lemma">lemma62</span></a> : ∀ (<span class="id" type="var">f</span>:B → <span class="id" type="keyword">Prop</span>)(<span class="id" type="var">l</span>:list <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>)(<span class="id" type="var">basecase</span>:Prop)(P:Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">R</span>:Prop)(x:B) ⇒ <span class="id" type="var">R</span> ∧ (<span class="id" type="var">f</span> <span class="id" type="var">x</span>)) <span class="id" type="var">l</span> <span class="id" type="var">basecase</span>) ∧ <span class="id" type="var">P</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">R</span>:Prop)(x:B) ⇒ <span class="id" type="var">R</span> ∧ (<span class="id" type="var">f</span> <span class="id" type="var">x</span>)) <span class="id" type="var">l</span> (<span class="id" type="var">basecase</span> ∧ <span class="id" type="var">P</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.lemma5"><span class="id" type="lemma">lemma5</span></a> (<span class="id" type="var">X</span>:B → <span class="id" type="keyword">Prop</span>)(<span class="id" type="var">ys</span>:list <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>)(<span class="id" type="var">n</span>:nat)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">H</span>:fold_left (<span class="id" type="keyword">fun</span> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">x</span> : <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>) ⇒ <span class="id" type="var">P</span> ∧ (<span class="id" type="var">X</span> <span class="id" type="var">x</span> ∨ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="filters.html#cba.enum"><span class="id" type="axiom">enum</span></a> <span class="id" type="var">x</span> = <span class="id" type="var">n</span> ∧ <a class="idref" href="filters.html#filter_completion.equiconsistent"><span class="id" type="definition">equiconsistent</span></a> <span class="id" type="var">X</span> (<a class="idref" href="filters.html#filter_completion.up"><span class="id" type="definition">up</span></a> (<a class="idref" href="filters.html#filter_completion.union_singl"><span class="id" type="definition">union_singl</span></a> <span class="id" type="var">X</span> <span class="id" type="var">x</span>))))) <span class="id" type="var">ys</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">x</span> : <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>) ⇒ <span class="id" type="var">P</span> ∧ <span class="id" type="var">X</span> <span class="id" type="var">x</span>) <span class="id" type="var">ys</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> ∨<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(∃ <span class="id" type="var">x_n</span> : <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#In"><span class="id" type="definition">In</span></a> <span class="id" type="var">x_n</span> <span class="id" type="var">ys</span> ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <a class="idref" href="filters.html#cba.enum"><span class="id" type="axiom">enum</span></a> <span class="id" type="var">x_n</span> ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">x</span> : <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>) ⇒ <span class="id" type="var">P</span> ∧ <span class="id" type="var">X</span> <span class="id" type="var">x</span>) (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#remove"><span class="id" type="definition">remove</span></a> <a class="idref" href="filters.html#cba.id_B_dec"><span class="id" type="axiom">id_B_dec</span></a> <span class="id" type="var">x_n</span> <span class="id" type="var">ys</span>) <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="filters.html#filter_completion.equiconsistent"><span class="id" type="definition">equiconsistent</span></a> <span class="id" type="var">X</span> (<a class="idref" href="filters.html#filter_completion.up"><span class="id" type="definition">up</span></a> (<a class="idref" href="filters.html#filter_completion.union_singl"><span class="id" type="definition">union_singl</span></a> <span class="id" type="var">X</span> <span class="id" type="var">x_n</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Section</span> <a name="filter_completion.completion"><span class="id" type="section">completion</span></a>.<br/>

<br/>
</div>

<div class="doc">
This is the hearth of the argument, a fixpoint that, starting from a filter F, builds a complete filter extending F and equiconsistent to F. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <a name="filter_completion.completion.F"><span class="id" type="variable">F</span></a>:B → <span class="id" type="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span> <a name="filter_completion.F_"><span class="id" type="definition">F_</span></a> (<span class="id" type="var">n'</span>:nat) {<span class="id" type="keyword">struct</span> <span class="id" type="var">n'</span>} :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n'</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n</span>) ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">Fn</span> := <a class="idref" href="filters.html#F_"><span class="id" type="definition">F_</span></a> <span class="id" type="var">n</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">X</span> := <span class="id" type="keyword">fun</span> <span class="id" type="var">b</span>:B ⇒ <span class="id" type="var">Fn</span> <span class="id" type="var">b</span> ∨ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="filters.html#cba.enum"><span class="id" type="axiom">enum</span></a> <span class="id" type="var">b</span>=n ∧ <a class="idref" href="filters.html#filter_completion.equiconsistent"><span class="id" type="definition">equiconsistent</span></a> <span class="id" type="var">Fn</span> (<a class="idref" href="filters.html#filter_completion.up"><span class="id" type="definition">up</span></a> (<a class="idref" href="filters.html#filter_completion.union_singl"><span class="id" type="definition">union_singl</span></a> <span class="id" type="var">Fn</span> <span class="id" type="var">b</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">in</span> <a class="idref" href="filters.html#filter_completion.up"><span class="id" type="definition">up</span></a> <span class="id" type="var">X</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> ⇒ <span class="id" type="var">F</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <a name="filter_completion.Z"><span class="id" type="definition">Z</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">b</span>:B ⇒ ∃ <span class="id" type="var">n</span>:nat, (<a class="idref" href="filters.html#filter_completion.F_"><span class="id" type="definition">F_</span></a> <span class="id" type="var">n</span>) <span class="id" type="var">b</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.lem223"><span class="id" type="lemma">lem223</span></a> : ∀ (<span class="id" type="var">X</span>:B → <span class="id" type="keyword">Prop</span>) <span class="id" type="var">x</span>, <span class="id" type="var">X</span> <span class="id" type="var">x</span> → (<a class="idref" href="filters.html#filter_completion.up"><span class="id" type="definition">up</span></a> <span class="id" type="var">X</span>) <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.lem222"><span class="id" type="lemma">lem222</span></a> : ∀ <span class="id" type="var">n</span> <span class="id" type="var">m</span>, (<span class="id" type="var">n</span> ≤ <span class="id" type="var">m</span>)%nat → ∀ <span class="id" type="var">x</span>, (<a class="idref" href="filters.html#filter_completion.F_"><span class="id" type="definition">F_</span></a> <span class="id" type="var">n</span>) <span class="id" type="var">x</span> → (<a class="idref" href="filters.html#filter_completion.F_"><span class="id" type="definition">F_</span></a> <span class="id" type="var">m</span>) <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span> <a name="filter_completion.thm22"><span class="id" type="lemma">thm22</span></a> : <a class="idref" href="filters.html#filter_completion.Filter"><span class="id" type="record">Filter</span></a> <span class="id" type="var">F</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="filters.html#filter_completion.Filter"><span class="id" type="record">Filter</span></a> <a class="idref" href="filters.html#filter_completion.Z"><span class="id" type="definition">Z</span></a> ∧ <a class="idref" href="filters.html#filter_completion.equiconsistent"><span class="id" type="definition">equiconsistent</span></a> <span class="id" type="var">F</span> <a class="idref" href="filters.html#filter_completion.Z"><span class="id" type="definition">Z</span></a> ∧ <a class="idref" href="filters.html#filter_completion.complete"><span class="id" type="definition">complete</span></a> <a class="idref" href="filters.html#filter_completion.Z"><span class="id" type="definition">Z</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">End</span> <a class="idref" href="filters.html#filter_completion.completion"><span class="id" type="section">completion</span></a>.<br/>

<br/>
</div>

<div class="doc">
Some additional lemmas that are needed by classcomp.v 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Section</span> <a name="filter_completion.additional_lemmas"><span class="id" type="section">additional_lemmas</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.lemma8"><span class="id" type="lemma">lemma8</span></a> : ∀ (<span class="id" type="var">X</span>:B → <span class="id" type="keyword">Prop</span>)(<span class="id" type="var">f</span>:B)(ys:list <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a</span> : <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">b</span> : <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>) ⇒ <span class="id" type="var">a</span> ∧ (<a class="idref" href="filters.html#filter_completion.union_singl"><span class="id" type="definition">union_singl</span></a> <span class="id" type="var">X</span> <span class="id" type="var">f</span>) <span class="id" type="var">b</span>) <span class="id" type="var">ys</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a</span> : <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">b</span> : <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>) ⇒ <span class="id" type="var">a</span> ∧ <span class="id" type="var">X</span> <span class="id" type="var">b</span>) <span class="id" type="var">ys</span> <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> ∨<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#fold_left"><span class="id" type="definition">fold_left</span></a> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a</span> : <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">b</span> : <a class="idref" href="filters.html#cba.B"><span class="id" type="axiom">B</span></a>) ⇒ <span class="id" type="var">a</span> ∧ <span class="id" type="var">X</span> <span class="id" type="var">b</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Lists.List.html#remove"><span class="id" type="definition">remove</span></a> <a class="idref" href="filters.html#cba.id_B_dec"><span class="id" type="axiom">id_B_dec</span></a> <span class="id" type="var">f</span> <span class="id" type="var">ys</span>) <a class="idref" href="http://coq.inria.fr/distrib/8.2-bugfix/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span> <a name="filter_completion.leq_bott"><span class="id" type="lemma">leq_bott</span></a> : ∀ <span class="id" type="var">x</span>:B, <a class="idref" href="filters.html#filter_completion.leq"><span class="id" type="definition">leq</span></a> <a class="idref" href="filters.html#cba.bott"><span class="id" type="axiom">bott</span></a> <span class="id" type="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">End</span> <a class="idref" href="filters.html#filter_completion.additional_lemmas"><span class="id" type="section">additional_lemmas</span></a>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="filters.html#filter_completion"><span class="id" type="module">filter_completion</span></a>.<br/>

<br/>
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>